<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0072)http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html -->
<HTML><HEAD><TITLE>TRUSIX: Access Control Lists</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY>
<H3 align=right>NCSC-TG-020-A<BR>VERSION-1</H3>
<H1 align=center>NATIONAL COMPUTER SECURITY CENTER</H1>
<H1 align=center>TRUSTED UNIX WORKING GROUP (TRUSIX)<BR>RATIONALE FOR 
SELECTING<BR>ACCESS CONTROL LIST FEATURES<BR>FOR THE UNIX (R) SYSTEM</H1>
<H4 align=center>18 August 1989</H4>
<HR>

<P align=center><B>NATIONAL COMPUTER SECURITY CENTER</B><BR>FORT GEORGE G. 
MEADE, MARYLAND 20755-6000</P>
<P align=right>NCSC-TG-020-A<BR>Library No. S-232,508</P>
<H1 align=center><A name="HDR 2 7">FOREWORD</A></H1>The National Computer 
Security Center (NCSC) formed the Trusted UNIX Working Group (TRUSIX) in 1987 to 
provide technical guidance to vendors and evaluators involved in the development 
of Trusted Computer System Evaluation Criteria (TCSEC) class B3 trusted UNIX* 
systems. The NCSC specifically targeted the UNIX operating system for this 
guidance because of its growing popularity among the government and vendor 
communities. By addressing the class B3 issues, the NCSC believes that this 
information will also help vendors understand how evaluation interpretations 
will be made at the levels of trust below this class.TRUSIX is making no attempt 
to address the entire spectrum of technical problems associated with the 
development of division B systems; rather, the intent is to provide examples of 
implementations of those security features discernible at the user interface 
that will be acceptable at this level of trust.
<P>TRUSIX is not intended to be a standards body. nor does it intend to produce 
a de facto standard to compete against POSIX. Additionally, the TRUSIX documents 
are not to be construed as supplementary requirements to the TCSEC. The TCSEC is 
the only metric against which the trustworthiness of an operating system will be 
evaluated.
<P>This document, "Rationale for Selecting Access Control List (ACL) Features 
for the UNIX System," is the first in a series of companion documents being 
produced by TRUSIX. The guidelines described in this document provide 
alternative methods for implementing ACLs in the UNIX system.
<P>Recommendations for revision to this guideline are encouraged and will be 
reviewed periodically by the NCSC. Address all proposals for revision through 
appropriate channels to:
<P>
<DL>
  <DD>National Computer Security Center 
  <DD>9800 Savage Road 
  <DD>Fort George G. Meade, MD 20755-6000 
  <DD>Attention: Chief, Technical Guidleines Division </DD></DL>
<P>_________________________________ 18 August 1989 <BR>Patrick R. Gallagher, 
Jr.<BR>Director<BR>National Computer Security Center</P>_______________
<P>* UNIX is a registered trademark of AT&amp;T
<P>
<HR>

<H1 align=center><A name="HDR 2 9">ACKNOWLEDGMENTS</A></H1>Special recognition 
is extended to those members of the TRUSIX Working Group who participated in the 
Access Control List Subcommittee. Members of this subcommittee were: Craig 
Rubin, AT&amp;T Bell Laboratories (Co-Chair); Holly Traxler, National Computer 
Security Center (NCSC)/Institute for Defense Analyses (IDA) (Co-Chair); Bruce 
Calkins, NCSC; and Casey Schaufler, Sun Microsystems. Recognition is also 
extended to the following members of TRUSIX who provided input through 
discussion and comments: Bernie Badger, Harris Corporation; Caralyn Crescenzi, 
NCSC; Cynthia Irvine, Gemini Computers; Howard Israel, AT&amp;T Bell 
Laboratories; Frank Knowles. MITRE; James Menendez. NCSC; Dr. Eric Roskos, IDA; 
Rick Siebenaler, NCSC, Lucy Stasiak, AT&amp;T Bell Laboratories; Albert Tao, 
Gemini Computers; Dr. Charles Testa, Infosystems Technology, Incorporated (ITI), 
Mario Tinto, NCSC; Grant Wagner, NCSC; Larry Wehr, AT&amp;T Bell Laboratories; 
and Bruce D. Wilner, ITI.
<P>Acknowledgment is also extended to the members of the POSIX P1003.6 Security 
Subcommittee and to those members of the computer security community who 
contributed their time and expertise by actively participating in the review of 
this document. 
<HR>

<H1 align=center><A name="HDR 2 10">EXECUTIVE SUMMARY</A></H1>The Trusted UNIX 
Working Group (TRUSIX) has examined the issues surrounding implementation of 
access control lists (ACLs) in the UNIX System and has identified a set of 
recommendations for implementors of ACL features. These recommendations balance 
issues of compatibility with existing applications, ease of use and 
acceptability to the end user9 and architectural simplicity with the 
requirements for systems evaluated according to the Trusted Computer System 
Evaluation Criteria (TCSEC). The recommendations reflect the collected opinions 
and analyses of the participating vendors, evaluators, and researchers regarding 
implementation of ACL features.
<P>The recommendations of TRUSIX with regard to ACLs are as follows:
<P>
<UL>
  <LI>ACLs are required for files IPC objects, and UNIX system domain sockets. 
  Access control for sockets that use name spaces other than those local to the 
  UNIX system (UDP, TCP) must be addressed in the specification and evaluation 
  of the system involved, and are neither explicitly recommended nor exempted. 
  <P></P>
  <LI>Access modes specifiable via ACLs should include read, write, and execute; 
  other modes should be allowed to be added as desired, but no additional modes 
  should be required to be supported. 
  <LI>Each ACL entry should specify permissions for either a user or a group, 
  but not both. 
  <P></P>
  <LI>Permissions granted by an ACL entry are masked by the group class file 
  permission bits. 
  <P></P>
  <LI>Multiple concurrent groups should be supported. In addition, some method 
  of group subsetting should be provided. It is recommended that this subsetting 
  allow the user to become a member of only one group at login time, then to 
  dynamically add groups to or delete groups from the working group set as 
  required. 
  <P></P>
  <LI>A system-defined ordering of ACL evaluation that evaluates from most 
  specific to least specific is recommended. Where multiple concurrent groups 
  are in use, and more than one matching group is found in the ACL, permissions 
  granted by all matching groups should be ORed together. 
  <P></P>
  <LI>Modifications to mechanisms that change ownership, change the file 
  permission bits, or access object attributes are not recommended. 
  <P></P>
  <LI>Existing mechanisms for object access, inquiry, and deletion should not be 
  changed, and new parameters should not be added. Instead, new mechanism should 
  be created that make use of existing ones. The interface for mechanisms that 
  create objects should not be changed, except for the possible creation of a 
  default ACL. 
  <P></P>
  <LI>For the new mechanisms that are added to support ACL operations, get/set 
  operations should be used. These operations should be implemented via a single 
  system call with command arguments to specify the various operations. For 
  commands at the user interface, the names getacl and setacl are recommended. 
  <P></P>
  <LI>Named ACLs need not be supported. 
  <P></P>
  <LI>Provision of default ACLs for file system objects is recommended, along 
  with a user-specifiable mechanism for indicating whether or not they should be 
  used. 
  <P></P>
  <LI>Provision of default ACLs for IPC objects is not recommended. 
  <P></P>
  <LI>Default ACLs should be provided on a per-directory basis. Newly-created 
  subdirectories should inherit the default ACL of the parent directory. 
  <P></P>
  <LI>When a new object is created and ACL entries are attached via a default 
  ACL, the file group-class permission bits are not affected unless an explicit 
  mechanism is provided. </LI></UL>The preceding list summarizes the 
recommendations of the Trusted UNIX Working Group. The main body of this 
document discusses the rationale for these recommendations and gives further 
details of the recommendations themselves. The appendix, the TRUSIX ACL Worked 
Example, gives an example of how these recommendations might be implemented. 
<HR>

<H1 align=center>CONTENTS</H1>
<UL><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR 2 7"><B>FOREWORD</B></A> 
  <BR><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR 2 9"><B>ACKNOWLEDGMENTS</B></A> 
  <BR><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR 2 10"><B>EXECUTIVE 
  SUMMARY</B></A> <BR><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR1 2 13"><B>1. 
  Introduction</B></A> <BR><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR2 2 15"><B>2. 
  Goals</B></A> <BR><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR3 2 17"><B>3. 
  ACLs On Objects</B></A> 
  <UL><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR3.1 3 17">3.1 
    ACLs On IPC Objects</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR3.2 3 18">3.2 
    ACLs On Sockets</A> </UL><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR4 2 18"><B>4. 
  Additional Access Modes</B></A> 
  <UL><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR4.1 3 19">4.1 
    Require Additional Access Modes</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR4.2 3 19">4.2 
    Prohibit Additional Access Modes</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR4.3 3 19">4.3 
    Allow Additional Access Modes (With Control)</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR4.4 3 19">4.4 
    Allow Additional Access Modes (Without Control)</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR4.5 3 20">4.5 
    Recommendation</A> </UL><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR5 2 20"><B>5. 
  ACL Entry Type And Format</B></A> 
  <UL><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR5.1 3 20">5.1 
    User And Group Entries</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR5.2 3 22">5.2 
    User Or Group Entries</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR5.3 3 23">5.3 
    Recommendation</A> </UL><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR6 2 24"><B>6. 
  Relationship Of ACL And File Permission Bits</B></A> 
  <UL><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR6.1 3 24">6.1 
    ACL Always Replaces File Permission Bits (Pure ACL)</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR6.2 3 25">6.2 
    Owner Selects ACL Or File Permission Bits</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR6.3 3 26">6.3 
    Independent ACL And File Permission Bits (AND)</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR6.4 3 27">6.4 
    Independent ACL And File Permission Bits (OR)</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR6.5 3 28">6.5 
    File Permission Bits Contained Within ACL</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR6.6 3 30">6.6 
    ACL Masked By File Permission Bits</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR6.7 3 31">6.7 
    Recommendation</A> </UL><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR7 2 32"><B>7. 
  Group Semantics</B></A> 
  <UL><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR7.1 3 32">7.1 
    Single Group Membership</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR7.2 3 33">7.2 
    Multiple Concurrent Group Membership</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR7.3 3 34">7.3 
    Multiple Concurrent Groups With Subsetting</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR7.4 3 35">7.4 
    Recommendation</A> </UL><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR8 2 35"><B>8. 
  ACL Evaluation</B></A> 
  <UL><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR8.1 3 35">8.1 
    Ordering Of Classes</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR8.2 3 36">8.2 
    User-Defined Ordering</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR8.3 3 36">8.3 
    System-Defined Ordering</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR8.4 3 37">8.4 
    Multiple Group Evaluation</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR8.5 3 38">8.5 
    Recommendation</A> </UL><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR9 2 38"><B>9. 
  DAC Compatibility</B></A> 
  <UL><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR9.1 3 39">9.1 
    Changing Ownership Of An Object</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR9.2 3 39">9.2 
    Changing The File Permission Bits</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR9.3 3 40">9.3 
    Creating Objects</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR9.4 3 40">9.4 
    Accessing Object Attributes</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR9.5 3 41">9.5 
    Accessing Object Data</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR9.6 3 41">9.6 
    Recommendation</A> </UL><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR10 2 42"><B>10. 
  ACL System Calls And Commands</B></A> 
  <UL><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR10.1 3 43">10.1 
    Recommendation</A> </UL><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR11 2 43"><B>11. 
  Named ACLs</B></A> 
  <UL><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR11.1 3 43">11.1 
    Recommendation</A> </UL><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR12 2 44"><B>12. 
  Default ACLs</B></A> 
  <UL><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR12.1 3 44">12.1 
    No Default ACLs</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR12.2 3 44">12.2 
    Require Default ACLs</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR12.3 3 45">12.3 
    Provide Default ACLs</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR12.4 3 45">12.4 
    Recommendation</A> </UL><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR13 2 45"><B>13. 
  Location Of Default ACLs</B></A> 
  <UL><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR13.1 3 45">13.1 
    System Wide</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR13.2 3 46">13.2 
    Per Process</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR13.3 3 46">13.3 
    Per GID Of Created File</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR13.4 3 46">13.4 
    Per Directory</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR13.5 3 46">13.5 
    Recommendation</A> </UL><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR14 2 47"><B>14. 
  Interaction Of Default ACL Entries At File Creation</B></A> 
  <UL><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR14.1 3 47">14.1 
    OR File Group Class Permission Bits</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR14.2 3 47">14.2 
    AND File Group Class Permission Bits</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR14.3 3 48">14.3 
    No Change To File Group Class Permission Bits</A> <BR><A 
    href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR14.4 3 48">14.4 
    Recommendation</A> </UL><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR15 2 48"><B>15. 
  Summary</B></A> <BR><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR 2 49"><B>APPENDIX: 
  Worked Example</B></A> <BR><A 
  href="http://packetstorm.decepticons.org/docs/rainbow-books/NCSC-TG-020-A.html#HDR 2 102"><B>REFERENCES</B></A> 
</UL>
<HR>

<H1>TRUSIX Task Force: Rationale For Selecting Access Control List<BR>Features 
For The UNIX System</H1>
<H1><A name="HDR1 2 13">1. Introduction</A></H1>The intent of this document is 
to explore the issues involved in extending the UNIX System discretionary access 
control (DAC) mechanism. DAC is a means of controlling access to an object based 
on the identity of subjects and/or groups to which they belong. The controls are 
discretionary in the sense that they are chosen by the object owner.
<P>The DAC mechanism employed in the current UNIX System was designed for 
efficiency, flexibility. and ease of use. This mechanism allows and encourages 
the sharing of information, but at a very coarse granularity, via the use of 
file permission bits. File permission bits are associated with three classes: 
owner (sometimes referred to as "user"), group. and other. Access for each class 
is represented by a three-bit field allowing for read, write, and 
execute-permissions.
<P>Several methods exist for allowing discretionary access control on objects. 
These methods include capabilities, profiles. access control lists (ACLs), 
protection bits, and password DAC mechanisms. The intent was to select a DAC 
mechanism with finer granularity than the current file permission bits, while 
maximizing the compatibility with both the current mechanism and POSIX P1003.1. 
Review of the methods described in A Guide to Understanding Discretionary Access 
Control in Trusted Systems(2), and of the desired outcome, point to the use of 
ACLs. It should be noted that ACLs can be considered a straightforward extension 
of the existing UNIX system protection bits, since the protection bits may be 
interpreted to be a limited form of an ACL, which always contains three entries.
<P>It has been suggested that the fine granularity of control provided by ACLs 
may be simulated in UNIX systems by using the group mechanism. Groups are lists 
of users which may be used to specify who may access a file. In the worst case9 
all possible combinations of users would have to be represented in order to 
fully implement these lists. This corresponds to (2**M-1) groups, where M is the 
number of bits in the group-ID. Since the number of possible combinations of 
users needed to implement this scheme for N users is (2"N-1), the maximum number 
of users which could effectively utilize such a system would be limited to the 
number of bits in the group-ID. This number (often 16 or 32) is an unreasonably 
small number for most UNIX systems and the management of the groups by users 
would be difficult. Also, this scheme does not allow for individual users in the 
lists to have different access rights. All users in the group would be forced to 
have the access rights given by the file group class permission bits. Some 
differences in access rights could be simulated by using the file other class 
permission bits, but not with the same functionality as provided by conventional 
ACLs.
<P>The DAC features explored in this rationale are based on the DAC features 
requested by customers, the class B3 DAC requirements described in the DoD 
Trusted Computer Systems Evaluation Criteria [1] (TCSEC), and the DAC mechanisms 
used in existing trusted systems (e.g., Multics). Based on these inputs9 it has 
been determined that the current DAC mechanism in the UNIX System is adequate 
for most needs and that the only enhancement required is to allow reasonable, 
finer-grained control of objects. This provides the capability to share or deny 
access to individually specified users and/or groups and meets the class B3 
requirements of the TCSEC.
<P>The issues explored in this document will deal primarily with ACLs. Much of 
the terminology has been adopted from the P1003.1 document and the TCSEC; 
however, new terms will be defined when used. For most of the issues identified, 
alternative solutions are given along with a recommendation. Although an attempt 
was made to consider the' issues independently, it should be noted that sole of 
the issues are actually very dependent on each other and recommendations `made 
in some areas greatly influenced later recommendations.
<P>_______________
<P>* UNIX is a registered trademark of AT&amp;T
<P>
<HR>

<H1><A name="HDR2 2 15">2. Goals</A></H1>The primary goal in extending 
discretionary access control in the UNIX system is to provide a finer 
granularity of control in specifying user and/or group access to objects. This 
can be achieved through the addition of access control lists. The following is a 
list of additional goals for the extended DAC mechanism:
<P>
<UL>
  <LI>The mechanism should provide compatibility with the existing (currently 
  P1003.1) and emerging POSIX standards and with the current UNIX System DAC 
  mechanism. In the unlikely event of a conflict between the current UNIX System 
  DAC mechanism and POSIX, the POSIX interpretation will be used. In addition, 
  the semantics of existing interfaces should be maintained. 
  <P></P>
  <LI>The following requirements for DAC in the TCSEC at class B3 should be 
  fulfilled. "The TCB shall define and control access between named users and 
  named objects (e.g., files and programs) in the ADP system. The enforcement 
  mechanism (e.g., access control lists) shall allow users to specify and 
  control sharing of those objects, and shall provide controls to limit 
  propagation of access rights. The discretionary access control mechanism shall 
  either by explicit user action or by default, provide that objects are 
  protected from unauthorized access. These access controls shall be capable of 
  specifying, for each named object, a list of named individuals and a list of 
  groups of named individuals with their respective modes of access to that 
  object. Furthermore. for each such named object, it shall be possible to 
  specify a list of named individuals and a list of groups of named individuals 
  for which no access to the object is to be given. Access permissions to an 
  object by users not already possessing access permission shall only be 
  assigned by authorized users." 
  <P></P>
  <LI>Reasonable vendor extensions to the DAC mechanism should not be precluded. 
  For example, the specification of read, write and execute permissions should 
  be supported. Other permissions should not be required nor should they be 
  precluded as extensions. A minimum set of new interfaces and error codes 
  should be provided. The new command interfaces provided for the user must be 
  easy to use and the existing interfaces should continue to work as expected. 
  <P></P>
  <LI>Intermixing use of the existing and newly-defined DAC functions/commands 
  should provide reasonable results. Security should be maximized by opting for 
  more restrictive rather than less restrictive decisions when a choice must be 
  made. 
  <P></P>
  <LI>When changing DAC on an object, at no time shall access be more permissive 
  than either the initial or resulting access. </LI></UL>
<HR>

<H1><A name="HDR3 2 17">3. ACLs On Objects</A></H1>A system can support several 
different types of objects, e.g., system objects, public objects, named objects. 
System objects are entities internal to the TCB (e.g., system data structures) 
not directly accessible by the normal user and, as such, do not require 
discretionary access control. Public objects are objects readable but 
unmodifiable to the normal user (e.g., system clock) and thus also do not 
require discretionary access control. Named objects are objects readable and 
modifiable at the user interface (e.g., text files). The TCSEC class B3 
requirement for DAC states that access control must be enforced on all named 
objects in the system [1]. Although there may be some variance among different 
UNIX system implementations, there are two common classes of named objects that 
require ACLs. These classes are files (including regular. directory. special. 
and named pipes), and named IPC objects (including shared memory, message 
queues, semaphores, and sockets).
<P>It is these classes of objects that will be protected by the discretionary 
access control alternatives described later in the paper. It should be pointed 
out, however, that discretionary access can not always be completely determined 
solely by the file permission bits and the ACL associated with the object. It is 
possible to have objects which have been administratively configured for a 
specific access and thus not completely affected by user DAC, e.g., a file 
system mounted read-only. There are other instances where discretionary access 
of objects may be time-dependent and thus not completely based on a current DAC 
setting. Examples of this would be the inability to write a shared-text file 
while it is being executed or trying to execute a file while it is open for 
writing. These situations are acknowledged special cases and will not be 
considered in the general discussion of determining effective discretionary 
access.
<P>
<H2><A name="HDR3.1 3 17">3.1 ACLs On IPC Objects</A></H2>IPC objects are named 
objects and are thus require ACLs at class B3. Note that this does not include 
unnamed pipes which can only be used to connect related processes. Although the 
semantics of IPC mechanisms are slightly different from those of file system 
objects, a DAC scheme similar to that used for file system objects should easily 
be adaptable to IPC objects. For example, message queues utilize both a creator 
and an owner of an IPC object and maintain creator and owner UIDs and GIDs 
(cuid,uid, cgid,gid). User access is checked against the cuid and the uid, and 
group access is checked against the cgid and gid. This situation can easily be 
represented with ACLs by using additional ACL entries to represent the creator 
UID and GID. Additionally, some access modes associated with file system 
objects, such as execute, may not be applicable to IPC objects. This does not 
cause a problem as long as the modes are a subset of those defined for file 
system objects.
<P>
<H2><A name="HDR3.2 3 18">3.2 ACLs On Sockets</A></H2>Sockets are named objects 
and would thus require ACLs at class 83. UNIX system domain sockets use the file 
system name space for access control decisions and currently have file 
permission bits associated with them. Thus, domain sockets would also need to 
have ACLs associated with them. Other types of sockets which use other name 
spaces (UDP. TCP) are currently not protected with any type of access control. 
Since it is not clear whether these types of sockets could currently be included 
in an evaluated configuration, they will not be addressed at this time.
<P>
<HR>

<H1><A name="HDR4 2 18">4. Additional Access Modes</A></H1>Existing UNIX systems 
support three access modes: read, write, and execute/search. Additional access 
modes are conceivable, and may be convenient to add while adding ACLs. Various 
possibilities include:
<P>
<UL>
  <LI>read attributes of object 
  <LI>write attributes of object 
  <LI>append only to object 
  <LI>truncate data of object 
  <LI>delete object 
  <LI>lock object 
  <LI>restrict setuid execution of object 
  <LI>restrict access of object based on time. </LI></UL>Note that this is not an 
all-inclusive list.
<P>In this and subsequent sections, alternative implementations of a given topic 
are examined, followed by the TRUSIX recommendation.
<P>
<H2><A name="HDR4.1 3 19">4.1 Require Additional Access Modes</A></H2>In this 
approach to handling additional access modes, new access modes would be defined 
and required. This limits the availability of compliant implementations and 
impacts compatibility.
<P>
<H2><A name="HDR4.2 3 19">4.2 Prohibit Additional Access Modes</A></H2>In this 
approach, new access modes would explicitly not be allowed. Due to loss of 
flexibility, compliance with this scheme would limit implementation.
<P>
<H2><A name="HDR4.3 3 19">4.3 Allow Additional Access Modes (With 
Control)</A></H2><B></B>In this approach, new access modes would not be defined. 
Instead. the concept of and mechanism for adding new access modes would be 
defined. This allows a vendor to produce whatever additional access modes are 
desired. Since the mechanism for doing so is defined there is little chance of 
collisions or contradictions. The mechanisms must be defined and agreed upon by 
some regulating body which allocates access bits. Note no such body currently 
exists which has been tasked to allocate access bits.
<P>
<H2><A name="HDR4.4 3 19">4.4 Allow Additional Access Modes (Without 
Control)</A></H2>In this approach, additional access modes are neither defined 
nor precluded. This method allows a vendor to produce whatever additional access 
modes are desired, but there is no mechanism provided for adding new modes. 
There would be no control on the access modes vendors might add.
<P>
<H2><A name="HDR4.5 3 20">4.5 Recommendation</A></H2>We recommend allowing 
additional access modes, without control. There should be nothing precluding the 
addition of new access modes if desired. However, since there is nothing 
currently in the POSIX P1003.1 standard concerning additional access modes, no 
new access modes or mechanisms need be defined.
<P>
<HR>

<H1><A name="HDR5 2 20">5. ACL Entry Type And Format</A></H1>The manner in which 
an ACL entry refers to a user or group of users is an important factor in the 
usability of an ACL mechanism. The alternatives are to have an ACL entry contain 
either a user or group in an entry. or to have an ACL entry contain both a user 
and group. The issue is which of the alternatives is more suitable to a system 
utilizing ACLs.
<P>
<H2><A name="HDR5.1 3 20">5.1 User And Group Entries</A></H2>A user and group 
entry contains a reference to both a specific user and a specific group together 
as a [UID,GID] pair. The UID-specific and GID-specific entries can be 
represented as special "wildcard" cases (denoted by *) meaning any user or group 
will match that entry. Using this method, an ACL entry may refer to one user in 
a particular group [UID,GID], one user in any group [UID,*], any user in a 
particular group [*,GID], or any user in any group [*,*] which is equivalent to 
the file other class permission bits. A typical ACL utilizing entries of this 
type might look like the following:
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=right>user1.projA
    <TD align=middle>rw- 
  <TR>
    <TD align=right>user2.projB
    <TD align=middle>r-- 
  <TR>
    <TD align=right>user3.*
    <TD align=middle>rwx 
  <TR>
    <TD align=right>*.projA
    <TD align=middle>r-- 
  <TR>
    <TD align=right>*.*
    <TD align=middle>--- </TR></TBODY></TABLE>Implementations of protected 
subsystems is the only clear example that suggests using user and group ACL 
entries as a pair. Using the UNIX system setgid-on-exec feature, it is possible 
to build protected subsystems. Consider the following example which makes use of 
this feature.
<P>A database of tapes is maintained in /etc/tapedata. The database 
administrator (DBA) of the database wishes to produce a utility to control 
access to this database.To begin with, there are some rules for dealing with the 
database. Some users should have read and write access, others just read access, 
and still others should have no access to the database. Readers should only see 
data about their own tapes. In addition, since other database utilities have 
poor error handling, all updates to the database need to be made in the correct 
format.
<P>The DBA has written a utility named tapedb which can read and update the 
database. /etc/tapedata and tapedb both have the group tape associated with 
them, and tapedb has the set-group-id bit on. The DBA has also created an ACL 
for /etc/tapedata which contains the following entries:
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=right>user1.tape
    <TD align=middle>r-- 
  <TR>
    <TD align=right>user2.tape
    <TD align=middle>r-- 
  <TR>
    <TD align=right>user3.tape
    <TD align=middle>rw- 
  <TR>
    <TD align=right>user4.tape
    <TD align=middle>rw- 
  <TR>
    <TD align=right>*.*
    <TD align=middle>--- </TR></TBODY></TABLE>All users named in the ACL (in group 
tape) may read the database Only user3 and user4 (in group tape) may update the 
database. If the only way for a user to be a member of group tape is by 
executing tapedb, then the DBA is satisfied that /etc/tapedata is adequately 
protected.
<P>While this example suggests a useful application of user and group ACL 
entries, there are other ways to implement the example which do not require this 
ACL entry type functionality. As described in the following section, the same 
effect can be achieved through ACLs containing user or group entries.
<P>Additionally, identification by a user and group pair is not used in a UNIX 
System. In some systems, a user is identified by a user-ID, group-ID pair. In 
Multics, for example, a user is identified by a user-ID, project-ID pair. where 
a project-ID is equivalent to a group-ID on the UNIX system. User1 in projA. on 
a Multics system, is distinct from userl in projB. Since Multics users do not 
have the capability to change groups9 the only way for a user to be identified 
with another project would be to log in with another group-ID. In UNIX systems, 
however. a user is really only identified by the user-ID. Also, a user can 
easily change group-ID through the newgrp command or be associated with several 
groups at the same time if using a system with multiple groups. Thus, 
controlling access for a user while in a specific group is not as useful in a 
UNIX system.
<P>
<H2><A name="HDR5.2 3 22">5.2 User Or Group Entries</A></H2>A user or group 
entry contains a reference to either a specific user or a specific group, but 
only one at a time. Consider the following example, where u indicates the user 
class, g indicates the group class, and o indicates the other class:
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=left>u: user1
    <TD align=middle>rw- 
  <TR>
    <TD align=left>u: user2
    <TD align=middle>r-- 
  <TR>
    <TD align=left>u: user3
    <TD align=middle>rw- 
  <TR>
    <TD align=left>u: user4
    <TD align=middle>rw- 
  <TR>
    <TD align=left>g: projA
    <TD align=middle>r-- 
  <TR>
    <TD align=left>g: projB
    <TD align=middle>rw- 
  <TR>
    <TD align=left>o:
    <TD align=middle>rw- </TR></TBODY></TABLE>
<P>To address the protected subsystem implementation, consider again the tape 
database example described in the previous section. Rather than controlling 
access to the data, access can be controlled on two subprograms; one which reads 
data, the other which updates data. The ACL on the database, /etc/tapedata would 
be:
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=left>g: tapereaders
    <TD align=middle>r-- 
  <TR>
    <TD align=left>g: tapewirters
    <TD align=middle>rw- 
  <TR>
    <TD align=left>o:
    <TD align=middle>--- </TR></TBODY></TABLE>
<P>The user interface for access to the database is tapedb. The program tapedb 
is not setgid, however, it invokes two other programs, tapedb_read and 
tapedb_write, that are setgid. Only users allowed to read the database have 
execute permission on, tapedb_read, while only those allowed to update the 
database may execute tapedb_write. The ACL on tapedb_read would be:
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=left>u: user1
    <TD align=middle>--x 
  <TR>
    <TD align=left>u: user2
    <TD align=middle>--x 
  <TR>
    <TD align=left>u: user3
    <TD align=middle>--x 
  <TR>
    <TD align=left>u: user4
    <TD align=middle>--x 
  <TR>
    <TD align=left>o:
    <TD align=middle>--- </TR></TBODY></TABLE>
<P>The ACL on tapedb_write would be:
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=left>u: user3
    <TD align=middle>--x 
  <TR>
    <TD align=left>u: user4
    <TD align=middle>--x 
  <TR>
    <TD align=left>o:
    <TD align=middle>--- </TR></TBODY></TABLE>The program tapedb_read runs setgid to 
the group <B>tapereaders</B>, and the program tapedb_write runs setgid to the 
group <B>tapewriters</B>.
<P>Thus, the same protected subsystem can be provided through ACLs of type user 
or group.
<P>The main advantage of this scheme is that it provides more clarity for the 
user. This is considered to be a very important advantage as a user's 
understanding of such a mechanism is essential in promoting its correct usage. 
Additionally, this scheme removes the need for wildcard specifiers, thus 
eliminating the potential problems of picking an unused character as a 
specifier.
<P>
<H2><A name="HDR5.3 3 23">5.3 Recommendation</A></H2>User or group entries in 
ACLs are recommended. Since there is no clear need for the user-group paired 
entry scheme and there are several advantages to the user or group scheme, the 
user or group scheme is the preferred alternative. Examples were examined which 
claimed to require the use of user-group paired entries. One such example deals 
with protected subsystems as described above. Protected subsystems, a useful and 
important feature in a trusted system, can be implemented through other means 
not requiring user-group paired entries. We have "found that this is a limited 
class of applications and may be implemented with the user or group scheme with 
minimal effort. For UNIX systems with multiple groups, the user and group scheme 
becomes more difficult when determining access. Additionally, the user or group 
scheme follows the idea in UNIX systems that a user is only identified by 
user-ID and gives no special meaning to what a user can do while only in a 
certain group. Finally, although simplicity is a very subjective measure, in 
comparing the two alternatives the advantage of simplicity outweighs the ability 
to specify both a user and a group in a single entry.
<P>
<HR>

<H1><A name="HDR6 2 24">6. Relationship Of ACL And File Permission 
Bits</A></H1>ACLs expand upon the discretionary access control facility which is 
already provided by the file permission bits. Although file permission bits do 
not meet the TCSEC class B3 requirement for DAC, they are sufficient for many 
uses and are the only mechanism available to existing applications. Existing 
applications that are security-conscious use file permission bits to control 
access. The relationship between the ACL and the file permission bits is 
important to existing programs in order to maintain compatibility. For example, 
use of <B>chmod</B>("object" 0) should continue to work, denying subsequent 
opens to an object. The following sections discuss possible approaches to 
handling the interaction of ACLs with file permission bits. Any references to 
default ACLs will be fully described in the Default ACLs section.
<P>
<H2><A name="HDR6.1 3 24">6.1 ACL Always Replaces File Permission Bits (Pure 
ACL)</A></H2>In this approach, the file permission bits are no longer consulted 
for DAC decisions. Instead, each object always has an ACL and the ACL completely 
determines access.
<P>Consider the following example illustrating this scheme. Assume User1 and 
User2 are members of the group "GroupA" and User3 and User4 are not.
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=left>File Owner/Group:
    <TD align=left>User2/GroupA 
  <TR>
    <TD align=left>File Permission Bits:
    <TD align=left>rwxr-x--x 
  <TR>
    <TD align=left>ACL Entries: 
  <TR>
    <TD align=middle>User1
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User2
    <TD align=left>r-- 
  <TR>
    <TD align=middle>User3
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User4
    <TD align=left>--- </TR></TBODY></TABLE>
<P>In this example the file permission bits would have no effect on the access 
control decision. User3 is able to read, write and execute the file. User2 is 
able to read it, but not to execute or write to the file. The file permission 
bits are completely ignored.
<P>The resulting pure ACL system does not have to worry about interactions 
between the ACL and the file permission bits, since the latter are not used for 
access control decisions. A single, well defined access policy is employed. 
Applications which should make use of DAC are forced to understand the new 
rules.
<P>The major disadvantage of this scheme, however, is that compatibility is 
lost. Every DAC cognizant program, and that should be every program that 
manipulates the discretionary access control information on an object needs to 
be changed to understand ACLs.
<P>
<H2><A name="HDR6.2 3 25">6.2 Owner Selects ACL Or File Permission 
Bits</A></H2>In this approach, either the file permission bits or the ACL are 
consulted for the access control decision on a per object basis. The owner 
determines whether the file permission bits or the ACL is used. The system call 
chmod returns an indicative error if the object has an ACL, but otherwise sets 
the file permission bits.
<P>Consider the two following examples which illustrate this approach. Once 
again assume User1 and User2 are members of the group "GroupA" and User3 and 
User4 are not.
<P>Example A (ACL selected):
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=left>File Owner/Group:
    <TD align=left>User2/GroupA 
  <TR>
    <TD align=left>File Permission Bits:
    <TD align=left>rwxr-x--x 
  <TR>
    <TD align=left>ACL Entries: 
  <TR>
    <TD align=middle>User1
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User2
    <TD align=left>r-- 
  <TR>
    <TD align=middle>User3
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User4
    <TD align=left>--- </TR></TBODY></TABLE>
<P>Since there is an ACL on this file the access control is the same as in the 
previous example.
<P>Example B (file permission bits selected):
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=left>File Owner/Group:
    <TD align=left>User2/GroupA 
  <TR>
    <TD align=left>File Permission Bits:
    <TD align=left>rwxr-x--x 
  <TR>
    <TD align=left>ACL Entries:
    <TD align=left>NONE </TR></TBODY></TABLE>
<P>Since there are no ACL entries on this file the access control ~r determined 
by the permission bits. User2 (owner) has all access permissions to the file. 
User1 (a user in GroupA) is allowed read and execute access. User3 and User4 
("other" users) can only execute the file.
<P>The resulting system behaves like a file permission bit based system if no 
one ever sets ACLs and like the pure ACL system if a default ACL mechanism is in 
use. Thus, either environment can be supported.
<P>The compatibility issues raised in the previous section apply here as well. 
In addition, the programs have to determine which access control mechanism 
applies to each object created and set the DAC accordingly.
<P>
<H2><A name="HDR6.3 3 26">6.3 Independent ACL And File Permission Bits 
(AND)</A></H2>In this approach, both the file permission bits and the ACL are 
consulted for the discretionary access control decision on a per object basis. 
Access is granted if and only if it is granted by both the ACL and the file 
permission bits.
<P>Consider the following example, which illustrates this approach. For this 
example, assume only User2 is in GroupA.
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=left>File Owner/Group:
    <TD align=left>User2/GroupA 
  <TR>
    <TD align=left>File Permission Bits:
    <TD align=left>rwxr-x--x 
  <TR>
    <TD align=left>ACL Entries: 
  <TR>
    <TD align=middle>User1
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User2
    <TD align=left>r-- 
  <TR>
    <TD align=middle>User3
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User4
    <TD align=left>--- </TR></TBODY></TABLE>
<P>In the example above, the file permission bits imply that User1 has execute 
permission, whereas the permissions specified in the ACL imply that User1 has 
full access. Without knowing which group User 1 is in, one cannot predict 
whether or not User1 can read the file. If User1 is in group GroupA, then User1 
will have read and execute permissions. If User1 is not in group GroupA, then 
only execute permission will be granted. Similarly, without knowing User3's 
group, one cannot predict whether or not User3 has read access. User4 will have 
no possibility of access, due to no permissions specified in the ACL entry. As 
the example illustrates, there is no way to get a full ACL view with this 
scheme.
<P>With this scheme, some compatibility is maintained. Calls to chmod have the 
desired effect from the restrictive point of view. ACL entries can further 
restrict access.
<P>Making use of the ACL as the effective access control mechanism requires that 
the file permission bits be set wide-open (i.e., read, write, and execute bits 
are set for user, group and other). In situations where ACLs are not properly 
set, a new object will become generally accessible. Likewise, if the ACL is 
removed then the object will again be generally accessible. This scheme also 
allows for misleading status information given to programs which only use the 
existing mechanism.
<P>
<H2><A name="HDR6.4 3 27">6.4 Independent ACL And File Permission Bits 
(OR)</A></H2>In this approach, both the file permission bits and the ACL are 
consulted for the discretionary access control decision on a per object basis. 
Access is granted if it is granted by either the ACL or the file permission 
bits. The ACL is used to grant access beyond what is set in the file permission 
bits.
<P>Consider the following example illustrating this approach. Assume only User2 
is in GroupA.
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=left>File Owner/Group:
    <TD align=left>User2/GroupA 
  <TR>
    <TD align=left>File Permission Bits:
    <TD align=left>rwxr-x--x 
  <TR>
    <TD align=left>ACL Entries: 
  <TR>
    <TD align=middle>User1
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User2
    <TD align=left>r-- 
  <TR>
    <TD align=middle>User3
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User4
    <TD align=left>--- </TR></TBODY></TABLE>
<P>User1, User2, and User3 have read, write, and execute access. User4 has 
execute access.
<P>Again, some compatibility is maintained. Calls to chmod have the desired 
effect from the permissive point of view. The previous alternative's problem of 
leaving the permission bits wide-open is thus avoided.
<P>The problem with this scheme, however, is that a <B>chmod</B> call which 
would deny all access (<B>chmod</B>("object", 0)) in a system without ACLs will 
not do so here.
<P>
<H2><A name="HDR6.5 3 28">6.5 File Permission Bits Contained Within 
ACL</A></H2>In this approach, only the ACL is consulted for discretionary access 
control decisions. The file permission bits are replaced by three "base" entries 
in the ACL. Calls to <B>chmod</B> modify the <B>owner, group, and other</B> 
entries contained in the ACL. Calls to <B>stat</B> read this information from 
the ACL.
<P>In the following two examples assume the <B>owner</B> entry is evaluated 
before additional user entries, and the <B>group</B> entry is evaluated before 
additional gr1oup entries.
<P>Example A:
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=left>File Owner/Group:
    <TD align=left>User2/GroupA 
  <TR>
    <TD align=left>File Permission Bits:
    <TD align=left>rwxr-x--x 
  <TR>
    <TD align=left>ACL Entries: 
  <TR>
    <TD align=middle><B>owner</B>
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User1
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User2
    <TD align=left>r-- 
  <TR>
    <TD align=middle>User3
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User4
    <TD align=left>--- 
  <TR>
    <TD align=middle><B>group</B>
    <TD align=left>--- 
  <TR>
    <TD align=middle><B>other</B>
    <TD align=left>--- </TR></TBODY></TABLE>
<P>In this example. it is not clear what permissions User2 is to be granted, 
since a particular method for determining owner access has not been specified 
for the case where an additional user entry also names the owner. User2 could be 
granted read, write, and execute access as the owner. read access only, as per 
the explicit entry for User2, or some combination of the two (e.g., the AND or 
OR of the two). User1, User3, and User4 get their access from their ACL entries.
<P>Example B: (After a <B>chmod</B>("object", 0))
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=left>File Owner/Group:
    <TD align=left>User2/GroupA 
  <TR>
    <TD align=left>File Permission Bits:
    <TD align=left>--------- 
  <TR>
    <TD align=left>ACL Entries: 
  <TR>
    <TD align=middle><B>owner</B>
    <TD align=left>--- 
  <TR>
    <TD align=middle>User1
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User2
    <TD align=left>r-- 
  <TR>
    <TD align=middle>User3
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User4
    <TD align=left>--- 
  <TR>
    <TD align=middle><B>group</B>
    <TD align=left>--- 
  <TR>
    <TD align=middle><B>other</B>
    <TD align=left>--- </TR></TBODY></TABLE>
<P>Changing the file permission bits to zero does not change the permissions 
granted to User1, User3, and User4, since their access is based on ACL entries. 
User2's access may change depending on how owner access is determined when 
additional user entries naming the owner also exist.
<P>If no additional entries are added to the ACLs, this system looks like a 
system without ACLs. The literal meaning of the file permission bits is 
preserved in the ACL.
<P>As in the previous alternative, however, a <B>chmod</B> call which would deny 
all access (<B>chmod</B>("object", 0)) in a system without ACLs will not do so 
here.
<P>
<H2><A name="HDR6.6 3 30">6.6 ACL Masked By File Permission Bits</A></H2>In this 
approach, both the file permission bits and the ACL are used for determining the 
discretionary access control decision. The access indicated in the ACL entry is 
logically ANDed (masked) with one or more of the file permission bit classes 
(file owner, file group, or file other class) to determine the effective DAC 
permission.
<P>Example:
<P>
<TABLE align=center>
  <TBODY>
  <TR>
    <TD align=left>File Owner/Group:
    <TD align=left>User2/GroupA 
  <TR>
    <TD align=left>File Permission Bits:
    <TD align=left>rwxr-x--x 
  <TR>
    <TD align=left>ACL Entries: 
  <TR>
    <TD align=middle>User1
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User2
    <TD align=left>r-- 
  <TR>
    <TD align=middle>User3
    <TD align=left>rwx 
  <TR>
    <TD align=middle>User4
    <TD align=left>--- </TR></TBODY></TABLE>
<P>Assume that the group file permission bits are chosen as the mask, i.e., all 
ACL entries will be ANDed against the file group class permission bits. User2, 
being the owner, gets read, write, and execute access to the file. User3 is 
allowed read and execute access. User1 is allowed read and execute access, the 
write access is disallowed by the file permission bits. User4 is not allowed any 
access to the file.
<P>Calls to <B>chmod</B> have the desired effect from the restrictive point of 
view but not necessarily from the permissive point of view. Since the bits of 
the masked field will most likely be set wide-open, the literal meaning of the 
field chosen for the mask appears to be lost. The POSIX standard, however, 
allows for the extended meaning of the group class permission. bits.
<P>
<H2><A name="HDR6.7 3 31">6.7 Recommendation</A></H2>We recommend the <EM>ACL 
Masked By File Permission Bits</EM> approach. This is the most reasonable 
approach when trying to balance security and compatibility. The question of 
designating the masking field must still be resolved. The file group class 
permission bits are the preferred masking field, even though they encourage 
permissive default access by the owning group. This choice must be made because 
the use of the file owner class would cause compatibility problems in programs 
which attempt to establish "owner-only" access, whereas the designation of the 
file other class could leave objects open to attack were an ACL removed or never 
present. An additional option of masking user entries with the file owner class 
permission bits and group entries with the file group class permission bits has 
the same disadvantages as masking against only the file owner class. When 
masking against the file group class, the permissions indicate the least upper 
bound of the permissions allowed for the ACL entries and the user and other 
fields retain their previous semantics.
<P>To summarize the approaches identified in this section:
<P>The ACL Masked By File Permission Bits approach is a compromise for both 
security and compatibility.
<P>The Independent ACL And File Permission Bits (AND) approach suffers from the 
serious flaw that the file permission bits must be set very permissively in 
order to allow the ACL entries to predominate in the discretionary access 
calculation. A simple mistake in setting the ACL could grant object access to 
significantly more users than was intended.
<P>The Independent ACL And File Permission Bits (OR) approach may require that 
both ACL and the file permission bits be changed in order to deny a particular 
access. Thus, existing programs could believe that they had prevented access 
when they, in fact, had not. Similarly, in the File Permission Bits Contained 
Within ACL approach, removing "other" permission might not have the desired 
effect9 since, the owner, group, and other entries may not be the only ones in 
the ACL. In neither case does a call to <B>chmod</B> with a zero argument 
unequivocally revoke access from all users as might be expected.
<P>Whichever DAC scheme is ultimately selected, an appropriate balance must be 
struck between the mutually conflicting concerns of compatibility and security. 
In a DAC scheme where <B>chmod</B> cooperates with ACLs, <B>chmod</B> must not 
grant inappropriate access or require unreasonable (i.e., permissive public 
access) defaults.
<P>Barring compatibility, the alternatives of ACLs replacing file permission 
bits (Pure ACLs and On Demand) would be the most elegant way of enhancing DAC 
for UNIX systems. By abandoning file permission bits, however, these schemes 
have been rendered incompatible with existing systems. Thus, they are not 
considered for a POSIX-compliant UNIX system DAC scheme.
<P>
<HR>

<H1><A name="HDR7 2 32">7. Group Semantics</A></H1>There are various ways of 
using the UNIX system group mechanism when grouping system users. In designing 
ACLs it is important to understand the possible semantics and provide enough 
flexibility to properly support these semantics. Initially, there are no 
restrictions on how users can be grouped. Various possibilities include:
<P>
<UL>
  <LI>a shorthand way of referring to groups of subjects
  <P></P>
  <LI>a method of grouping project work by group access rights
  <P></P>
  <LI>privileged roles
  <P></P>
  <LI>accountability (file ownership)
  <P></P></LI></UL>The issue arises. however, of how to deal with user membership 
when considering these possible grouping mechanisms. For example, should a user 
be permitted to be a member of more than one group at any given time? If so. 
should there be a mechanism provided to allow the user to control group 
membership? These issues will be addressed in the following sections.
<P>
<H2><A name="HDR7.1 3 32">7.1 Single Group Membership</A></H2>Under a single 
membership scheme, a user can only be a member of one specific group at any 
given time. All discretionary access checks will be made with respect to the 
user's OlD and a single GID. A user will only be able to change his/her group 
through the use of the newgrp command. This scheme is easy to implement and 
introduces no additional complexity with respect to evaluating access within an 
ACL. Additionally. it would certainly be acceptable in a class B3 system.
<P>
<H2><A name="HDR7.2 3 33">7.2 Multiple Concurrent Group Membership</A></H2>Under 
a multiple concurrent group scheme, a user can be a member of more than one 
group at the same time. This scheme introduces some complexity when evaluating 
user access by allowing more than one ACL entry of equal specificity to apply to 
a user simultaneously. For example, if a user is a member of several groups at 
the same time and tries to access an object with an ACL containing entries which 
match the user on more than one group, what will the resulting access be? There 
ar several ways of determining the resulting access in such a case. These are 
discussed under ACL Evaluation.
<P>Another concern with the use of multiple concurrent groups is the possibility 
of violating the least privilege principle. With multiple concurrent groups if a 
user is in several groups at once, he/she is granted access to all of those 
groups at all times rather than to just the ones he/she needs at any given time. 
This could be contrary to the idea of a user having a minimal set of privileges 
necessary to perform a particular function at any given time.
<P>It can be argued, however, that the least privilege requirement in the TCSEC 
only applies to TCB architecture, making this issue irrelevant for DAC. On the 
other hand there may be a problem with a system which implements privileged 
roles through the group mechanism. The TCSEC class B3 Trusted Facility 
Management requirement states that separate roles must be assigned to operator 
and administrator functions and that each role be restricted to performing only 
those functions necessary for that role. Given a system, therefore, which uses 
the group mechanism to assign roles and grant access based on role identity to 
parts of the system which would otherwise be inaccessible, it is clear that 
least privilege could be violated through the use of multiple concurrent groups. 
The violation would occur if the user who was a member of the group assigned to 
a privileged role could also be a member of one or more additional groups. 
Proper administration of these privileged groups, however. could still allow for 
the use of multiple groups. but a subsetting capability, as described in the 
next subsection, would then be required.
<P>Improperly controlled multiple concurrent groups with groups representing 
privileged roles could therefore be a violation of the least privilege 
principle. This would result in a failure to meet the class B3 requirements. 
This is only one specific implementation, however, and it is certainly 
conceivable that multiple concurrent groups could be implemented in such a way 
as to not be a violation of least privilege. The multiple concurrent group 
scheme is currently a feature in some UNIX systems and is thought to be an 
extremely useful and necessary feature to those who use it. Multiple concurrent 
groups would also be compatible with the POSIX standard
<P>
<H2><A name="HDR7.3 3 34">7.3 Multiple Concurrent Groups With 
Subsetting</A></H2>Another problem associated with multiple concurrent groups 
arises from the fact that currently when a user logs on to a system he/she 
automatically becomes a member of all of the groups that he/she is allowed 
membership in. There is no way for the user to only be active in a subset of 
his/her possible group set. Although there is no explicit requirement in the 
TCSEC precluding this, the TCSEC does seem to imply that a user should by 
default have a minimal amount of access rights at login.
<P>There are several ways of approaching this problem; any of these methods 
would be a possible and acceptable means of resolving this problem. First, it is 
necessary to consider whether a user should be able to add or delete groups from 
his/her group set and if so, with what restrictions. A user should certainly not 
be allowed to add groups for which he/she is not authorized. Therefore each user 
should have an "allowable group set" which consists of all groups that user has 
been given authorization to be a member of. Adding groups other than those which 
appear in this allowable group set would be unacceptable.
<P>There are at least two ways to allow a user to work with a subset of his/her 
allowable group set. The first would be to keep the current scheme where a user 
becomes a member of all of his/her groups at login, but provide the user with a 
means (through some system call or command) to drop specific groups if desired 
and work as a member of some subset of his/her allowable group set. A command 
would allow a user the capability but require an explicit action to do so. A 
system call, on the other hand, would provide the means for restriction through 
a program which could be set up to run automatically for the user. This would 
mean, however, that the set of groups would either be hardcoded into the program 
or be set through some type of configuration file. Another possible approach 
would be to provide a mechanism that would cause a program's groups to be 
restricted when that program is executed. Although this eliminates the user 
having to remember to restrict his/her groups or having to hardcode a group set 
into a program, it would add further complexity to the system.
<P>
<H2><A name="HDR7.4 3 35">7.4 Recommendation</A></H2>We recommend that the 
multiple concurrent group capability be provided along with some method of 
subsetting. The preferred method would be to only allow the user to become a 
member of one group at login and provide him/her with a means of dynamically 
adding/deleting to his/her working group set. This recommendation, of course, 
may conflict with implementations which use the group mechanism for privilege 
roles.
<P>
<HR>

<H1><A name="HDR8 2 35">8. ACL Evaluation</A></H1>This issue deals with how an 
ACL is evaluated to determine access rights of a subject to a particular object. 
There are several possible ordering methods for ACL evaluation, as well as 
several different ways to evaluate multiple group entries.
<P>Two levels of ordering must actually be considered when deriving an ACL 
evaluation scheme; the ordering of the classes (user, group, other), and then 
the ordering of the entries within each class.
<P>
<H2><A name="HDR8.1 3 35">8.1 Ordering Of Classes</A></H2>It would certainly be 
possible to specify an ordering of any combination of the three classes, user, 
group, and other. However, since both the POSIX standard and all current UNIX 
systems specify a "user, then group, then other" ordering, (or most-to-least 
specific), when evaluating access with permission bits, this ordering should be 
maintained for ACLs as well.
<P>The method of evaluating an ACL in a most-to-least specific manner can be 
described as follows. The owner identity of the object is first checked against 
the effective identity of the subject. If there is a match the search stops. 
Next, a check is made against the owning group identity of the object and the 
effective group of the subject. If there is a match and the subject does not 
have multiple groups, the search stops. Otherwise the rest of the group entries 
are searched next. If the subject has multiple groups, the group entries are 
evaluated as presented in the Multiple Group Evaluation section, otherwise they 
are searched in order as the user entries are. Finally, if no user or group 
entries were found to match the effective identity of the subject, access is 
determined based on the <B>other entry.</B>
<P>For the following discussion on the ordering of ACL entries9 it will be 
assumed that the classes will be ordered and follow this most-to-least specific 
regime.
<P>
<H2><A name="HDR8.2 3 36">8.2 User-Defined Ordering</A></H2>In this method, 
entries are considered according to the ordering given by the user. The first 
entry as specified by the user is considered first, the second entry next, and 
soon.
<P>As long as the "user, then group, then other" order is followed, the only 
security relevant problem with this method occurs when evaluating group entries 
with multiple groups. If a user is a member of multiple groups and matches more 
than one of the group entries, the resulting access may be dependent upon the 
ordering of the group entries. See the Multiple Group Evaluation section for 
various possibilities. Unless all matching group entries are considered when 
determining access, the burden is placed on the user to correctly order the 
group entries.
<P>This method may appear to be more convenient for users, however, it may 
require the user to have extensive knowledge of group membership. Additionally, 
it does not allow for very efficient access evaluation as discussed in the 
following section.
<P>
<H2><A name="HDR8.3 3 36">8.3 System-Defined Ordering</A></H2>In this method, 
entries are considered according to a system-defined ordering. Although the user 
does not have the flexibility of choosing an arbitrary order of entries, a 
system-defined ordering gives consistency to ACLs throughout the system and may 
also allow for quicker access determination.
<P>The system may use any of a variety of ordering methods, two of which are 
alphabetical ordering by user or group name and numeric ordering by user or 
group ID. An ordering of lowest to highest UID or GID, or vice-versa, is 
recommended as it provides an efficient way to check for redundant entries. 
Redundant entries should not be allowed in an ACL.
<P>It is important to mention that actual sorting need not be done by the kernel 
itself as long as the kernel enforces the specified ordering. In other words, 
the sorting can be achieved through the use of library routines. The ACL 
commands would automatically use the library sorting routines and users would 
also be encouraged to do so when writing their own programs which manipulate 
ACLs. When an ACL passed to the kernel, the kernel verifies that the entries are 
sorted or else a failure will occur. In this manner, efficiency is achieved 
while still enforcing a system-defined ordering.
<P>This alternative is simple. reduces the possibility of user error, and allows 
for more efficient access determination.
<P>
<H2><A name="HDR8.4 3 37">8.4 Multiple Group Evaluation</A></H2>When a subject 
is a member of multiple groups, there are several ways the group entries may be 
evaluated, regardless of the ordering of the entries.
<P>The following methods may be used to evaluate access when multiple groups are 
used:
<P>The first entry which matches one of the subject's groups might be used to 
determine access. While this is an efficient method, it does not take notice of 
the possibility of other groups granting access.
<P>The entry which matches one of the subject's groups and grants the least 
access might be used. This method does not recognize the possibility that all 
the groups together might grant or deny the desired access.
<P>The entry which matches one of the subject's groups and grants the most 
access might be used. This method also does not recognize the possibility that 
all the groups together might grant or deny access.
<P>ANDing the permissions of all the entries which match groups of the subject 
is another possible method. This approach may be considered too restrictive, 
since even one entry which grants access may be overruled by other entries which 
deny access.
<P>ORing the permissions of all the entries which match groups of the subject is 
also a possibility. This method may be considered too permissive, since the 
maximum permissions allowed by all the matching entries taken together is the 
result. However, the same effect can be achieved currently, through the user 
simply invoking the newgrp command to change to the group with the d1esired 
access or by opening the same file twice from two different groups which 
together provide the desired access.
<P>
<H2><A name="HDR8.5 3 38">8.5 Recommendation</A></H2>A system-defined ordering 
which evaluates ACLs entries from most-to-least specific is recommended. Since 
multiple groups were designed to be permissive and permissive results can be 
achieved through other means anyway, the method which ORs the permissions of all 
matching group entries is recommended for systems implementing multiple groups.
<P>Concern has been expressed that this scheme violates the wording in the 
TCSEC, for DAC at class B3. The TCSEC states: Furthermore, for each such named 
object, it shall be possible to specify a list of named individuals and a list 
of groups of named individuals for which no access to the object is to be given. 
The ORing of groups, however, does not present a conflict with the class B3 DAC 
requirement, as it still allows the user to specify groups that shall have no 
access.
<P>
<HR>

<H1><A name="HDR9 2 38">9. DAC Compatibility</A></H1>Designing an ACL mechanism 
requires that attention be given to the use of system calls which check or 
modify the existing DAC mechanisms, and to the additional use of ACL mechanisms 
in system calls. The classes of DAC mechanisms which return or change the value 
of the discretionary access control information are those mechanisms which: 
change ownership of an object, change the file permission bits, create objects, 
access object attributes. and access object data. Each of these classes will now 
be examined and a determination will be made of what changes, if any, are 
required for inclusion in a system with ACLs. For each class, we provide 
alternative solutions and identify the preferred choice.
<P>
<H2><A name="HDR9.1 3 39">9.1 Changing Ownership Of An Object</A></H2>Mechanisms 
which change ownership of an object (e.g., <B>chown, msgctl, semctl, shmctl</B>) 
could create a new user or group entry for the object owner or group, with the 
same access permissions as the original entry for the object owner or group. The 
original entry would become an additional user or group entry. The problem with 
this alternative is that by leaving the original entry for the object owner or 
group behind as an additional user or group entry, the mechanism will always 
create an ACL for an object which did not have one to begin with.
<P>The preferred alternative is for these calls to suffer no additional side 
effects due to the presence of ACLs. This can be achieved by not storing 
explicit IDs in the owner and owning group ACL entries. An advantage of this 
alternative is that the ACL entries for object owner and object owning group can 
be readily distinguished syntactically from the other user and group entries.
<P>
<H2><A name="HDR9.2 3 39">9.2 Changing The File Permission 
Bits</A></H2>Mechanisms which change the file permission bits (e.g., <B>chmod, 
msgctl, semctl, shmctl</B>) might be changed so that they fail, or partially 
fail, when presented with an object that has an ACL.
<P>Complete failure is a poor alternative since these mechanisms change the file 
mode, not just the file permission bits. For example, a program should be able 
to do a legitimate operation such as changing the setgid bit on any file.
<P>Partial failure means that these mechanisms would make the requested changes 
but return an error value different from -1. This is a poor alternative for two 
reasons: it does not make good sense to succeed while returning failure. and 
programs often do not differentiate between error return values.
<P>Other alternatives attempt to minimize surprises to the caller by changing 
ACL entries. The first of these alternatives is to mask the access permissions 
in all the object's additional entries. Access permissions for entries with 
specific user and specific group are ANDed with the supplied user and group 
access permissions. Access permissions for entries with only a specific user are 
ANDed with supplied permissions for the user, and permissions for entries with 
only a specific group are ANDed with supplied permissions for the group. While 
this meets POSIX requirements, programs that wish to change only the file mode 
(non-access) bits will have the masking occur as an undesirable side effect. 
Another alternative is to disable the additional entries. This implicitly 
requires a new mechanism to enable entries that have been disabled. POSIX 
requirements are also satisfied by this alternative, but the same problems exist 
as in the previous alternative; programs using these mechanisms to change the 
non-access file mode bits will have entries disabled as an undesirable side 
effect. Still another alternative is to delete the additional entries. This has 
similar advantages and disadvantages as ACL entry disabling. It is simpler since 
there is no need for an ACL entry enabling mechanism. Information given by the 
user, however, is deleted without warning.
<P>The preferred method is to make no changes to these mechanisms. The 
mechanisms will affect only file permission bits and ACL entries for the object 
owner or group. While this does not provide non-ACL cognizant programs with 
expected results for operations on objects with ACLs, it is not perceived as a 
serious problem. This alternative is consistent with the preferred alternative 
for mechanisms which access object attributes as well (see below).
<P>
<H2><A name="HDR9.3 3 40">9.3 Creating Objects</A></H2>Mechanisms which create 
or truncate objects (e.g., <B>creat, open, mkfifo, mkdir, msgget, semget, 
shmget</B>) should work as they currently do, except that they may create an ACL 
as part of the default ACL mechanism. Please refer to the section on default 
ACLs for more information. Note that default protection on newly-created objects 
will be accomplished via the umask and/or default ACLs.
<P>It may also be desirable to add other types of ACL features to mechanisms. 
For example, one might wish to add the capability during file creation to adopt 
a specific ACL. For changes of this type, parameters of existing mechanisms 
should not be changed, and new parameters should not be added. New mechanisms 
should be created which make use of existing ones. For example. <B>creat</B> may 
need to be modified to take ACLs into account, but the parameter list should not 
change. Instead of adding an ACL parameter to <B>creat</B>, a new system call 
(i.e. with some other name) should be used. which takes the ACL as a parameter 
and then uses <B>creat</B>.
<P>
<H2><A name="HDR9.4 3 40">9.4 Accessing Object Attributes</A></H2>Mechanisms 
which access object attributes (e.g. <B>stat, msgctl, semctl, shmctl</B>) could 
be modified to fail when applied to an object with an ACL. This is an 
unacceptable alternative since these mechanisms return more information than 
simply the file mode. Thus. non-functionality would require a new mechanism to 
return the additional information for objects with ACLs.</B>
<P>Another alternative is to find all the entries in the ACL that apply to the 
user-ID and group-ID of the subject, just like a permissive access check. Then 
OR all the associated permissions together, and return the results in the 
appropriate file permission bits (user, group, and other). While this 
alternative integrates the idea of ACLs into mechanisms that access object 
attributes9 the context of the mechanisms affects the result returned to the 
point where the meaning of what the mechanisms return is somewhat clouded.
<P>The preferred alternative is to make no changes to these mechanisms. The 
mechanisms will continue to return the file permission bits as if ACLs did not 
exist. Another mechanism must then be used to find out if the file has an ACL, 
and if so, what its entries are. While this alternative does not provide all 
information to subjects that don't know about ACLs, it does not change the 
current behavior of these mechanisms.
<P>
<H2><A name="HDR9.5 3 41">9.5 Accessing Object Data</A></H2>There are a number 
of system calls which will need to have AFL functionality added to them (i.e., 
for access checking). These calls include all those taking file system object 
names as parameters, as well as those IPC mechanisms which perform access 
checks. Examples of some of these calls are: <B>open, msgsnd, msgrcv, semop,</B> 
and <B>shmat</B>.
<P>It is also important for portability that programs use the available access 
control mechanisms in an appropriate manner, so that the security policy is 
interpreted correctly. For instance, at the system call level, the permission 
information returned by the use of <B>stat</B> may not be sufficient to 
determine allowed access; other information such as ACL contents may have to be 
evaluated as well.
<P>
<H2><A name="HDR9.6 3 41">9.6 Recommendation</A></H2>The following is a summary 
of the preferred alternatives stated in this section. Regarding compatibility 
with existing DAC mechanisms that either 1) change ownership or group of an 
object. 2) change file permission bits, or 3) access object attributes should 
remain unchanged and not affect an existing ACL on the object or create an ACL 
where one did not exist before.
<P>Regarding the addition of ACL functionality, existing mechanisms should not 
be changed, and new parameters should not be added. Instead, new mechanisms 
should be created which make use of existing ones.
<P>
<HR>

<H1><A name="HDR10 2 42">10. ACL System Calls And Commands</A></H1>This issue 
addresses what the naming conventions and functionality for ACL system calls and 
commands should be.
<P>For system calls, there are at least two alternative types of designs. Each 
depends on how the ACL is viewed. In one approach, the ACL is a series of 
independent records which can be individually manipulated using calls similar to 
<B>open, read, write,</B> and <B>close</B>. This approach has a nice parallel to 
the way files are read and written, but may be viewed as overly complicated 
given the relative infrequency of ACL modification. In the other approach. the 
ACL is considered a single unit and is not changed record-by-record, but instead 
always manipulated as a whole. This approach uses a "get" and "set" concept for 
ACL operations, where an ACL, as a whole, is retrieved, modified locally, and 
then replaced [3]. This approach is simple and reflects the growing trend 
towards get/set type operations.
<P>It may also be reasonable to extend the "get" and "set" concept to apply to 
default ACLs as well as to the ACL associated with an object. This is a natural 
extension of the way ACLs would be manipulated, and default ACL operations may 
be easily added to the recommended system call interface described below.
<P>There are also two possible methods for implementing these calls. One option 
is to use separate system calls for each of the ACL operations (i.e., getacl, 
setacl). The other option is to have one ACL system call that can be invoked 
with a number of command arguments indicating the desired ACL operation [3]. An 
example of a useful additional command argument is one that would return the 
number of entries in the ACL. This method conserves the number of system calls, 
and provides the flexibility to add ACL commands via command arguments. 
Additionally, using this method, designers are free to implement library 
functions based on the system call with particular command flags.
<P>For commands, the same issues apply as for system calls. In a system with 
ACLs, however, there will be a need for commands to not only manipulate ACLs, 
but also to show and manipulate all discretionary access control information. 
These commands should include. at a minimum:
<P>
<UL>
  <LI>command(s) to retrieve and set file permission and mode bits (ls, chmod)
  <P></P>
  <LI>command(s) to retrieve and set ACL information (new)
  <P></P>
  <LI>command(s) to retrieve effective discretionary access to files (new)
  <P></P></LI></UL>In addition, there may be useful features to add to existing 
utilities (e.g., the ability to find a file according to its ACL [12]) so that 
they might be able to conform to the enhanced DAC mechanisms.
<P>
<H2><A name="HDR10.1 3 43">10.1 Recommendation</A></H2>For the ACL system call 
interface, get/set ACL type operations should be used9 and should be implemented 
with a unified system call with command arguments used to implement the various 
operations. For commands. the names <B>getacl</B> and <B>setacl</B> are 
recommended since they follow from the get/set concept.
<P>
<HR>

<H1><A name="HDR11 2 43">11. Named ACLs</A></H1>A named ACL, as described in A 
Guide to Understanding Discretionary Access Control in Trusted Systems [2], is 
an ACL that can be shared or referred to by name. They may be implemented in one 
of two ways; either as a template copied into a user's ACL or shared through a 
pointer from the user's ACL space (shared ACL).
<P>A change to a shared ACL results in a change to the discretionary access on 
all objects using this ACL. This result may be considered to be a side-effect or 
a desired feature depending on the circumstance. Additionally, it may be 
difficult to determine which objects are sharing a specific named ACL, and a 
user may mistakenly grant access to an object that was not intended.
<P>Another problem with named ACLs is that as objects they may themselves be 
required to contain discretionary access controls. This suggests the idea of 
recursive ACLs, a situation to be avoided.
<P>
<H2><A name="HDR11.1 3 43">11.1 Recommendation</A></H2>Named ACLs need not be 
supported. but a system that does should be no less secure or less flexible than 
one that does not. Absolute flexibility of ACLs can be achieved, however, 
through the use of default ACLs as discussed in the following section. There is 
no strong case one way or the other for named ACLs. There are advantages and 
disadvantages to both alternatives and it would really depend on the environment 
as to whether named ACLs would be of any benefit.
<P>
<H1><A name="HDR12 2 44">12 Default ACLs</A></H1>When considering ACLs, an issue 
arises as to whether a predesignated set of ACL entries should be assigned to an 
object automatically at the time of creation. The following alternatives present 
the possible ways to address this issue.
<P>
<H2><A name="HDR12.1 3 44">12.1 No Default ACLs</A></H2>In this approach, no ACL 
is assigned at object creation time. The process umask will limit the file 
permission bits, as it currently does, to provide some default protection on an 
object.
<P>While this alternative maintains compatibility with existing programs, it is 
not a very practical solution. Depending on the relationship of the file 
permission bits and the ACL, the absence of default ACLs may not make sense. For 
instance, in a pure ACL implementation, the absence of default ACLs would result 
in no initial protection on newly created files. Additionally, this alternative 
would not encourage the use of ACLs by new programs, and would prevent ACL 
creation by old programs. ACLs could not propagate through the system and hence 
their usability would be lost.
<P>
<H2><A name="HDR12.2 3 44">12.2 Require Default ACLs</A></H2>In this approach, 
an ACL would always be assigned at object creation time. This would allow for 
initial finer grained control on an object.
<P>Requiring default ACLs may cause incompatibilities for an old program that 
only looks at the file permission bits when it creates an object. Also, for many 
users, the umask may be a sufficient tool for limiting the permissions on an 
object when it is created. The main advantage of requiring default ACLs is that 
the usability of ACLs is greatly improved. Additionally, since an ACL is 
associated with an object in a single atomic operation, the possibility of a 
temporarily insecure state is avoided.
<P>
<H2><A name="HDR12.3 3 45">12.3 Provide Default ACLs</A></H2>A mechanism is 
provided to put default ACLs on new objects. However9 not all new objects need 
to have default ACLs. This alternative allows specification of a default ACL, 
giving a finer granularity of access control than that provided by the file 
permission bits, and, at the same time allows, where desired, compatibility with 
existing programs.
<P>
<H2><A name="HDR12.4 3 45">12.4 Recommendation</A></H2><B></B>Providing default 
ACLs and mechanisms to specify whether or not to use them is the best solution. 
This allows both classes of users, those who want default ACLs and those who do 
not (even those who want no ACLs at all), the flexibility to specify the scheme 
that they find most appropriate. Although in many cases the process umask would 
be sufficient to assign default permissions, systems and/or users making 
explicit use of ACLs will desire default ACLs. The default ACL scheme used 
should be straightforward to the user and should sensibly interact with the 
existing DAC mechanisms, including the umask mechanism. Note that even if an 
object is created with no default ACL, ACL entries may still be added to the 
object.
<P>This section has really only addressed default ACLs on file system objects. 
IPC objects are not part of the file system name space, and therefore require 
further consideration. IPC objects are relatively short lived. and are generally 
not manipulated by users at the command level as are files. Based on these 
characteristics default ACLs on IPC objects are probably not needed, and their 
use is not recommended.
<P>
<HR>

<H1><A name="HDR13 2 45">13. Location Of Default ACLs</A></H1>Consider the 
following possibilities for the origination of the default ACL.
<P>
<H2><A name="HDR13.1 3 45">13.1 System Wide</A></H2>In this approach, one 
specific default ACL is assigned to any object created on the system by any 
subject. This is a very inflexible solution and misses the intent that 
discretionary access be set at the discretion of the user.
<P>
<H2><A name="HDR13.2 3 46">13.2 Per Process</A></H2>In this approach, each user 
process defines a default ACL, similar to the umask currently used. This is a 
somewhat restrictive approach since this allows the user to set only a single 
set of defaults for all files created. It is likely that a user will wish to 
associate different default ACLs with files created for different projects. 
Additionally, the default ACL entries would have to be stored in the process 
area. The amount of process space required to hold the entries would vary based 
on the number of entries.
<P>
<H2><A name="HDR13.3 3 46">13.3 Per GID Of Created File</A></H2>A default ACL 
could be associated with each GID. If GIDs are viewed as project identifiers, 
the effect is to associate a unique default ACL within each project subtree of 
the file system hierarchy. Further, in some UNIX Systems, where GIDs propagate 
to newly created objects based on the GID of the creating directory (rather than 
upon that of the creating subject), default protection very naturally 
distributes across the file system. However this variant imposes a somewhat 
restrictive viewpoint on the utility of groups.
<P>
<H2><A name="HDR13.4 3 46">13.4 Per Directory</A></H2>This approach would allow 
the object's default ACL to originate from the containing directory of the 
object. A directory would contain both an ACL to be used for access checking and 
a default ACL to be used when a new object is created in the directory. All 
objects created in the directory would be assigned the default ACL. Newly 
created subdirectories would inherit the default ACL of the parent directory. In 
this manner, the default will propagate down through the file system structure 
resulting in much duplication of ACLs, possibly using much space. However, the 
utilization of such space is a small price to pay for enhanced security and 
usability, so the default should probably continue to propagate until the user 
takes some explicit action to stop the propagation.
<P>
<H2><A name="HDR13.5 3 46">13.5 Recommendation</A></H2>A user typically arranges 
objects per directory representing project work or areas of interest. Since it 
is desirable, then, for similar objects to contain the same ACL, the 
per-directory approach becomes the preferred mechanism. Newly-created 
subdirectories should inherit the default ACL of the parent directory, so that 
defaults are propagated down the file system, unless explicitly turned off.
<P>
<HR>

<H1><A name="HDR14 2 47">14. Interaction Of Default ACL Entries At File 
Creation</A></H1>Currently, when a file is created a user can specify its 
initial permissions, however the access can be further restricted by the umask 
mechanism. The umask specifies the default protection bit settings when a file 
is created. Any bits set in the umask will be cleared in the bit settings on the 
newly created file. It is important, then, to consider how the default 
permission bit settings should interact with the entries in a default ACL.
<P>Consider the following options in the context of masking the ACL entries by 
the file group class permission bits as recommended in the ACL Evaluation 
section. Also note that these options are discussed with respect; to the ACL 
entry types as described in the ACL Entry Type and Format section. Additional 
mechanisms in the ACL which allow direct modification of the file group class 
permission bits at file creation are not precluded.
<P>
<H2><A name="HDR14.1 3 47">14.1 OR File Group Class Permission Bits</A></H2>Add 
the default entries to the file and change the file group class permission bits 
to reflect the maximum permissions allowed in the ACL. This could result in more 
permission than was specified in the creation call. It is not reasonable to 
assume that the default permission bit settings can be ignored and completely 
overridden by the ACL. For example, if a default entry exists for user "fred" 
with the specified permissions of "rwx" but the file is not executable, then 
this permission should not be given.
<P>
<H2><A name="HDR14.2 3 47">14.2 AND File Group Class Permission Bits</A></H2>Add 
the default entries to the file but change the permissions of the ACL entries so 
that they are no greater than the file group class permission bits. This is a 
reasonable alternative, but it may present a compatibility problem for some 
applications. An example of this problem would be when a C compiler creates a 
file. The file would not originally be created with execute permission, 
therefore no ACL entries on the file (which were default entries copied from the 
directory) would have execute permission. The last step for the compiler would 
be to make the file executable, however at this point, execute permission' which 
may have been specified in the default ACL entry is lost.
<P>
<H2><A name="HDR14.3 3 48">14.3 No Change To File Group Class Permission 
Bits</A></H2>Add the default entries to the file but do not change the file 
group class permission bits. This may result in ACL entries which are restricted 
by the file group class permission bits.
<P>
<H2><A name="HDR14.4 3 48">14.4 Recommendation</A></H2>The No Change To File 
Group Class Permission Bits is recommended since it is a reasonable alternative 
which does not present any problems of compatibility for some applications.
<P>
<HR>

<H1><A name="HDR15 2 48">15. Summary</A></H1>This document has provided an 
analysis of key issues involved in extending the discretionary access control in 
the UNIX system. For each of the issues identified, the paper has suggested 
alternative solutions, discussed the pros and cons of each, and then provided a 
recommendation.
<P>The following is a review of some of the important recommendations presented 
in the paper. An access control list mechanism was chosen to extend the current 
DAC mechanism. When considering the types of access provided in the UNIX system, 
additional access modes need not be defined, however they should also not be 
precluded. The recommended ACL entry type was that of user or group entries. The 
main advantages of this solution are conformance with the UNIX system method of 
identification through either the user-ID or the group-ID, and simplicity for 
the user. The method in which file protection bits and ACLs interact is a very 
important and complex issue given the conflicting goals of security and 
compatibility. The recommendation of masking the ACL entries by the group field 
of the protection bits was chosen as the most accommodating solution considering 
these goals. A system defined ordering of the ACL entries was preferred and it 
was recommended that the access allowed for a user in multiple groups should be 
the sum of all access allowed for each group represented in the ACL. Considering 
other multiple group issues9 it was recommended to provide the multiple 
concurrent group capability along with some method of subsetting. It was also 
recommended that default ACLs be provided and that they originate from the 
parent directory of the newly created object.
<P>It is important to note that although these and other specific 
recommendations were given, it is certainly possible to design an acceptable 
class B3, POSIX-compliant UNIX system following some of the other alternatives. 
In fact, there are issues where the recommended solution may not be superior to 
another alternative and the designer should consider his/her own specific 
requirements when making a choice in those areas. It must also be pointed out 
that building a system following all the recommendations presented in this paper 
will not guarantee a full class B3 system. There are many additional class B3 
requirements that go beyond the interface specification.
<P>
<HR>

<H1 align=center><A name="HDR 2 49">APPENDIX: Worked Example</A></H1>
<H1>A.1 Introduction and Overview</H1>
<UL></UL>This worked example describes one particular Implementation following 
the recommendations in the TRUSIX rationale.
<P>
<H2>A.1.1 Discretionary Access Control</H2>Discretionary access control (DAC) 
provides for the controlled sharing of objects (e.g., files, IPC objects) 
between subjects (e.g., processes). With discretionary access control, the owner 
of an object can grant permissions to other users. The discretionary access 
control mechanism uses object owner, object group, file permission bits (nine 
permission bits) and the access control list (ACL) of an object to determine the 
discretionary access to the object.
<P>This document will detail the DAC interfaces and their run-time behavior.
<P>The goals of this ACL mechanism were:
<P>
<UL>
  <LI>compatibility with the current UNIX System DAC mechanism and POSIX P1003.1 

  <LI>user command interfaces that are easy to use and understand 
  <UL>
    <LI>adhere to the "principle of least astonishment" </LI></UL>
  <LI>interfaces should continue to work as expected 
  <UL>
    <LI>chmod 000 file - no access to file 
    <LI>chmod 700 file - only owner access to file 
    <LI>chmod 444 file - denies write and execute access to file 
</LI></UL></LI></UL>In addition, intermixing use of the existing and new DAC 
commands should give reasonable results. For instance chmod should not fail due 
to ACLs, and when <EM>chmod x file</EM> is executed (<EM>x</EM> is an octal 
permission) <EM>ls -l</EM> displays <EM>x</EM> as the permissions. The current 
output of <EM>ls -l</EM> displays the file permission bits as a constant width 
set of nine characters:
<P>
<DL>
  <DD>rwxrwxrwx </DD></DL>
<P>However, an ACL, which consists of one or more <B>user</B> entries, one or 
more <B>group</B> entries, one <B>class</B> entry, and one <B>other</B> entry, 
is not a constant length (in the following example, * indicates zero or more 
occurrences of the preceding entry type):
<P>
<DL>
  <DD># file: filename 
  <DD># owner: uid 
  <DD>#group:gid 
  <DD><B>user</B>::rwx 
  <DD><B>user</B>:uid:rwx 
  <DD>* 
  <DD><B>group</B>::rwx 
  <DD><B>group</B>:gid:rwx 
  <DD>* 
  <DD><B>class</B>:rwx </DD></DL>The file permission bits shown by the Is command 
have the following meaning: (note the following "class" definitions are from the 
IEEE POSIX Std 1003.1-1988):
<P>
<DL>
  <DD>1. the first 3 bits (high order) represent the file owner class and define 
  the permissions for the object owner,
  <P></P>
  <DD>2. the middle 3 bits (commonly called the group permission bits), 
  represent the file group class. This class includes the owning group of the 
  file and will be extended to include additional <B>user</B> and additional 
  <B>group</B> ACL entries,
  <P></P>
  <DD>3. the last 3 bits (low order) represent the file other class and define 
  the permissions for other (those that did not fall into 1 or 2 above).
  <P></P></DD></DL>These nine bits indicate the maximum discretionary permissions 
for an object. The actual permissions may always be less than indicated. For 
instance, the permission may indicate write access on an object by a specific 
subject, but the file system may be mounted read only. If an ACL mechanism is 
used these bits will continue to indicate the maximum discretionary permissions 
for the object and the ACL may further restrict permissions.
<P>There is a direct mapping between the ACL and the file permission bits. 
Specifically, the file owner class permission bits will always be equal to the 
permissions of the ACL entry for the object owner (they may be the same bits 
depending upon the implementation). Additionally, the file other class 
permission bits will always be equal to the ACL <B>other</B> entry permissions. 
And the file group class permission bits will always be equal to the ACL 
<B>class</B> entry permissions. Typically, the file group class permission bits 
are set to the maximum permissions allowed to the additional <B>user</B> 
entries, the owning <B>group</B> entry, and the additional <B>group</B> entries.
<P>Whenever a file is created on a file system that supports ACLs, the ACL will 
contain a <B>user</B> entry for the object owner, a <B>group</B> entry for the 
object owning group, a <B>class</B> entry for the file group class permissions, 
and an <B>other</B> entry for the rest of the world. For compatibility with the 
current mechanism, if the ACL contains no additional <B>user</B> or additional 
<B>group</B> entries, the permissions in the <B>group</B> entry for the object 
owning group and the <B>class</B> entry must be the same.</B>
<P>
<H2>A.1.2 Use of Access Control Lists</H2>The use of DAC with ACLs will be 
explained by comparing it to how a user of a non-ACL supporting UNIX System (as 
currently exists) would use DAC. To use the current DAC mechanism a user usually 
first executes ls -l and based on the output decides what the permissions must 
be changed to. in order to allow the desired access (for example the user may 
want to make the file executable, or only allow the owner to have write 
permission).
<P>EXAMPLE:
<P>$ ls -l foo<BR>-rw-rw-rw- 1 craig demo 53 Mar 6 17:37 foo
<P>$ chmod 600 foo
<P>$ ls -l foo<BR>-rw------- 1 craig demo 53 Mar 6 17:37 foo
<P>In the new DAC mechanism, using a pure ACL, there will be two new commands 
<EM>getacl</EM> and <EM>setacl</EM> (there will be a new function, <EM>acl</EM>, 
for which these commands provide a user interface). The <EM>getacl</EM> command 
will be used to display the ACL and the <EM>setacl</EM> command will be used to 
change the ACL.
<P>These commands will be used in much the same way that Is and chmod are used. 
A user would first execute getacl to look at the ACL and then use setacl to make 
the desired changes. Because the ACL is not a fixed size, it may be difficult to 
manipulate. In order to simplify the use of ACLs the following example shows how 
the ACL may be easily manipulated using a text editor to give greater 
flexibility (note that changes may also be specified on the setacl command 
line).
<P>EXAMPLE:
<P>#the output of getacl is redirected to the file tmp<BR>$ getacl bar &gt; tmp
<P>#the file tmp is edited and the line in italics is inserted<BR>$ vi tmp<BR># 
file: bar<BR># owner: craig<BR># group: 
demo<BR>user::rw-<BR>group::rw-<BR>group:guest:r--<BR>class:rw-<BR>other:rw-
<P>#setacl is executed and the contents of the file tmp become the new ACL for 
bar<BR>$ setacl -f tmp bar
<P>#the output from getacl for the file bar is displayed<BR>$ getacl bar<BR># 
file: bar<BR># owner: craig<BR># group: 
demo<BR>user::rw-<BR>group::rw-<BR>group:guest:r--<BR>class:rw-<BR>other:rw-
<P>
<H2>A.1.3 Structure of Access Control Lists</H2>The ACL consists of the 
following types of entries, which must be in the following order:
<P>
<DL>
  <DD>1. <B>user</B> entry - This type of entry contains a user ID and the 
  permissions associated with it. There must always exist one entry of this 
  type, which will represent the object owner, and will be denoted by a null 
  (unspecified) user ID. There may be additional <B>user</B> entries specified; 
  however, no two additional <B>user</B> entries will have the same user ID and 
  there may not be any additional entries with a null user ID. The term 
  "additional <B>user</B> entries" will be used to indicate all user entries 
  except the entry for the object owner.
  <P></P>
  <DD>2. <B>group</B> entry - This type of entry contains a group ID and the 
  permissions associated with it. There must always exist one entry of this 
  type, which will represent the object owning group, and will be denoted by a 
  null (unspecified) group ID. There may be additional <B>group</B> entries 
  specified; however. no two additional <B>group</B> entries may have the same 
  group ID and there may not be any additional entries with a null group ID. The 
  term "additional <B>group</B> entries" will be used to indicate all 
  <B>group</B> entries except the entry for the object owning group.
  <P></P>
  <DD>3. <B>class</B> entry - This type of entry contains the maximum 
  permissions granted to the file group class. There is exactly one of these 
  entries in an ACL.
  <P></P>
  <DD>4. <B>other</B> entry - This type of entry contains the permissions 
  granted to a subject if none of the above entries have been matched. There is 
  exactly one of these entries in an ACL.
  <P></P>
  <DD>5. <B>default</B> entry - This type of entry may only exist on a 
  directory. These entries are similar to the entries described above, except 
  that they are never used in an access check, but are used to indicate the 
  non-default ACL entries that should be added to a file created within the 
  directory. Default entries are optional, but no two default entries may have 
  the same type and ID.
  <P></P></DD></DL>Within each category the entries must be ordered as follows:
<P>Entries in the <B>user</B> category shall be sorted numerically by user ID 
from lowest to highest, except for the object owner entry which always precedes 
all other user entries.
<P>Entries in the <B>group</B> category shall be sorted numerically by group ID 
from lowest to highest, except for the object owning group entry, which always 
precedes all other group entries.
<P>Entries in the <B>default:user</B> category shall be sorted numerically by 
user ID from lowest to highest, except for the default object owner entry, which 
always precedes all other default user entries. Entries in the 
<B>default:group</B> category shall be sorted numerically by group ID from 
lowest to highest, except for the default object owning group entry, which 
always precedes all other default group entries. The proper ordering of entries 
required by the acl function can be obtained by the use of the aclsort function. 
ACL entries given as input to the setacl command need not be sorted; the sorting 
will be performed by the setacl command.
<P>The permissions that may be specified in an ACL entry are read(r), write(w), 
and execute/search(x).
<P>When the <EM>setacl</EM> command is executed, the file owner class permission 
bits will be set to the permissions specified for the owner and the file other 
class permission bits will be set to the permissions specified for <B>other</B>. 
As an option, the file group class permission bits will be manipulated such that 
they reflect the maximum permission that the ACL permits to members of the file 
group class (any ACL entry other than the object owner or other). Otherwise, the 
file group class permission bits will be set to the permissions specified by the 
class entry. Therefore, if the file group class only allows read permission then 
additional user entries and any group entries in the ACL will not grant write or 
execute permission.
<P>This ACL scheme supports finer discretionary access controls than the current 
mechanism, while maintaining compatibility with the current permissions 
mechanism. The DAC information may be changed in one atomic operation, avoiding 
the possibility of an intermediate insecure state. Finer controls can be 
specified via the ACL, including explicit specification of users disallowed any 
access to the object. Additionally, the file permission bits provide a summary 
of all access rights.
<P><B>Rationale:</B> The ACL scheme described here will allow entries to be 
either permissive or restrictive. In general, an entry that results in less 
permission than the file other class permissions would grant would be considered 
restrictive. An entry that results in more permission than the file other class 
permissions would grant would be considered permissive. In the event that a file 
with an ACL is exported to a non-ACL system, the loss of permissive entries 
would not present a security problem; however, the absence of support for 
restrictive entries may allow a process to have permission that it would not 
have been granted on a system with ACLs. This behavior must be described in the 
documentation.
<P>
<H2>A.1.4 Discretionary Access Check Algorithm</H2>A process may request read, 
write, or execute/search access permissions to a file. Each access mode is 
logically checked separately using the following algorithm. The process request 
is granted if all individually requested modes are granted. Otherwise, the 
access request is denied.
<P>Note, this is a logical description of the access check. The physical code 
sequence may be different for better performance. 
<P>Discretionary Access Check Algorithm:
<P>
<DL>
  <DD>I. File Owner Class: If the effective user ID of the process matches the 
  user ID of the owner of the file, the process is in the file owner class. If 
  the requested access mode bit is set in the file owner class permission bits, 
  this access mode is granted. Otherwise, access is denied.
  <P>Note, the <B>user</B> ACL entry for the object owner matches the file owner 
  <B>class</B> permission bits.
  <P></P>
  <DD>II. File Group Class: If the process is not in the file owner class and if 
  the effective user ID of the process matches the user ID of an additional 
  <B>user</B> ACL entry or the effective group ID or any of the supplementary 
  group IDs of the process matches the group ID of any <B>group</B> ACL entry, 
  the process is in the file group class. If the process matched an additional 
  <B>user</B> ACL entry, only that entry is used as the matching ACL entry; 
  otherwise, the matching <B>group</B> ACL entry or entries are used. If the 
  requested access mode bit is set in the file group class permission bits and 
  is set in a matching ACL entry, this access mode is granted. Otherwise, access 
  is denied.
  <P>Note, the permissions of the additional <B>user</B> or <B>group</B> ACL 
  entries further restrict the access specified by the file group class 
  permission bits. Also, the class ACL entry matches the file group <B>class</B> 
  permission bits.
  <P></P>
  <DD>III. File Other Class: If the process is not in the file owner class or 
  file group class, the process is in the file other class. If the requested 
  access mode bit is set in the file other class permission bits, this access 
  mode is granted. Otherwise, access is denied.
  <P>Note, the <B>other</B> ACL entry matches the file other class permission 
  bits.
  <P></P></DD></DL>The following examples show ACL use and the results of applying 
current and new DAC commands.
<P>EXAMPLE 1:
<P># create file foo<BR>$ &gt; foo
<P>#execute ls -l and getacl on the file foo<BR>$ ls -l foo<BR>-rw-r--r-- 1 
craig demo 0 Mar 620:27 foo
<P>$ getacl foo<BR># file: foo<BR># owner: Craig<BR># group: 
demo<BR>user::rw-<BR>group::r--<BR>class:r--<BR>other:r---
<P>EXAMPLE 2:
<P>#execute getacl and Is -I on the file, run.sh, with added ACL entries<BR>$ ls 
-I run.sh<BR>-rwxr-xr-x+ 1 Craig demo 73 Mar 620:27 run.sh
<P>$ getacl run.sh<BR># file: run.sh<BR># owner: Craig<BR># group: 
demo<BR>user::rwx<BR>user:fred:r-x<BR>user:larry:--x<BR>group::r-x<BR>group:guest:---<BR>class:r-x<BR>other:r-x
<P>EXAMPLE 3:
<P>#use the chmod command on a file with an ACL<BR>#use getacl to report both 
the ACL entries and the effective permissions<BR>$ chmod 644 run.sh
<P>$ ls -l run.sh<BR>-rw-r--r--+ 1 craig demo 73 Mar 620:27 run.sh
<P>$ getacl run.sh<BR># file: run.sh<BR># owner: craig<BR>#group: 
demo<BR>user::rw-<BR>user:fred:r-x #effective:r--<BR>user:larry:--x 
#effective:---<BR>group::r-x #effective:r--<BR>group 
guest:---<BR>class:r--<BR>other:r--
<P>
<H2>A.1.5 File Object Creation</H2>When a new object (regular files, special 
files, directories, named pipes) is created in the file system, there are 
several important attributes that must be initialized. These are the user ID of 
the owner of the file, the group ID associated with the file, the file 
permission bits, and the ACL.
<P>The user ID of the file is set to the effective user ID of the invoking 
process. The group ID of the file depends upon the mode of the containing 
directory. If the S_ISGID bit is not set on the directory, the group ID of the 
file is set to the effective group ID of the invoking process. If the S_ISGID 
bit is set on the directory, the group ID of the file is set to the group ID of 
the containing directory.
<P>Each function that creates a new file supplies an initial value for the file 
permission bits. This initial value is then merged with the file mode creation 
mask (umask) of the invoking process and with any default ACL entries of the 
containing directory to form the file permission bits and ACL of the new file.
<P>Although in many cases the process <B>umask</B> is sufficient to assign 
default permissions, users making explicit use of ACLs may desire default ACLs. 
The default ACL scheme must sensibly interact with the existing DAC mechanism, 
including umask.
<P>The default ACL entries specify permissions for users and/or groups and/or 
others, that will be assigned to a new file. These default ACL entries are 
associated with a directory. Note, an ACL on a directory may contain entries 
that control access to the directory and entries (defaults) used for new file 
creation in that directory.
<P>The process of creating the file permission bits and the ACL for the new file 
is called "ACL Merge". First, any mode parameter is transformed into the 
equivalent ACL form. For example, the mode 0664 is equivalent to user::rw-, 
group::rw-, class:rw-, other:r--. Also, the complement of the umask is used to 
obtain the equivalent ACL. Thus, the umask 022 is equivalent to user::rwx, 
group::r-x, class:r-x, other:r-x.
<P>Two ACLs are merged by first logically sorting both ACLs into one ACL. Then 
any pair of matching entries are replaced with an entry that has permissions 
formed by ANDing the matched entries. Thus a permission is in the merged entry 
only if it was previously in both entries.
<P>The first ACL merge is with the initial mode from the file creation function 
and with the process file mode creation mask. The second ACL merge is with any 
default entries from the containing directory. The result is the ACL for the new 
file. The file permission bits are then set from the <B>user, class</B>, and 
<B>other</B> ACL entries. Note, this may be different from the setacl command 
with the -r option since this merge does not set the file group class permission 
bits to the maximum permission of the file group class entries.
<P>Finally, if the new object is a directory, then any default entries from the 
containing directory are copied to the new ACL. That is, the default ACL entries 
of the new directory are the same as the default ACL entries of the containing 
directory.
<P>An example of the ACL merge operation is shown in the following figure:
<P><B>FIGURE MISSING!</B> 
<P>
<H2>A.1.6 IPC Object Creation</H2>When an IPC object is created (by shmget for 
shared memory, by semget for semaphores, by msgget for messages), its cuid and 
uid will be set equal to the effective user ID of the invoking process and its 
cgid and gid will be set equal to the effective group ID of the invoking 
process. The initial permissions are set equal to the specified permissions in 
the flag argument to the *get calls (shmflg, semflg, and msgflg, respectively). 
Note that default ACLs do not apply to IPC objects, although ACLs may be added 
explicitly to an IPC object via the <B>aclipc</B> call.
<P>
<H2>1.7 Compatibility Requirements</H2>A user will generally use the current DAC 
commands (<EM>ls</EM> and <EM>chmod</EM>) or the new DAC commands 
(<EM>getacl</EM> and <EM>setacl</EM>). However, the use of these commands are 
likely to still be inter-mixed, and they must all give correct information. The 
entire interface to the current discretionary access control information must 
continue to function as it currently does. For example, chmod must still be able 
to modify the file permission bits and Is must still be able to report them.
<P>Note that although Is will still report these permissions. they will not be 
the only permissions evaluated during an access check. The output of Is will 
continue to be the maximum permission that may be granted, but there may be 
additional discretionary access control information (ACL entries) that was added 
to the object. In order to indicate that additional entries exist, Is-I will 
display the character "+" to the right of the current permissions display if an 
ACL is present. Therefore, when additional discretionary access control 
information has been added, in the form of ACL entries (as shown in the examples 
on previous pages), a user will need to use the newly provided command, getacl, 
to get a full view of the current discretionary access controls in effect. 
Although chmod will still modify the file permission bits, it will not change 
any additional discretionary access control information (i .e., ACL entries for 
additional users and additional groups) added to the object. To change these 
additional entries if they exist, the user will need to use the setacl command.
<P>When the owner of an object is changed, the result will be identical to the 
current behavior. If the owner is changed to a user ID for which an additional 
user entry already exists in the ACL, the additional user entry is not changed 
but the user entry for the object owner will take precedence during an access 
check. When the group of an object is changed. the result will be identical to 
the current behavior. If the group is changed to a group ID for which an 
additional <B>group</B> entry already exists in the ACL, the additional 
<B>group</B> entry is not changed but the <B>group</B> entry for the object 
owning group will take precedence during an access check (except in the case of 
multiple concurrent groups, where all group entries are given equal treatment).
<P>When the ACL contains no additional <B>user</B> or additional <B>group</B> 
entries, the permissions in the <B>group</B> entry for the object owning group 
and in the <B>class</B> entry must be the same. This behavior is the same as the 
current mechanism since the file permission bits can only specify at most three 
different permissions.
<P>
<H2>1.8 Documentation Requirements</H2>The ACL mechanism and its proper use must 
be fully described in the Trusted Facility Manual and manual pages must be 
created for the Security Features User's Guide and Security Features 
Programmer's Guide for all new commands and functions.
<P>
<HR>

<H1>A.2 Commands and Functions</H1>
<H2>2.1 setacl Command</H2>DESCRIPION: The setacl command will support the 
changing of discretionary permission information associated with a file. It will 
allow the file owner or a process with appropriate permission or appropriate 
privilege to perform the following functions:
<P>
<DL>
  <DD>1. replace an entire ACL, including the default ACL entries on a 
  directory, 
  <DD>2. add, change, or delete an ACL or default ACL entry or entries. </DD></DL>
<P>This command gives the user an interface to a pure ACL mechanism, allowing a 
finer granularity for file access. Note that this command only supports the file 
system objects: e.g., regular files, special files, directories, and named 
pipes. For simplicity, these objects are referred to as "files".
<P>SYNOPSIS:
<P>
<DL>setacl [-r] [ -rn [<B>u</B>[<B>ser</B>]::operm | perm[,]] 
  <DD>[<B>u</B>[<B>ser</B>]:uid:operm | perm[,...]] 
  <DD>[<B>g</B>[<B>roup</B>]::operm | perm[,]] 
  <DD>[<B>g</B>[<B>roup</B>]:gid:operm | perm[,...]] 
  <DD>[<B>c</B>[<B>lass</B>]:operm | perm[,]] 
  <DD>[<B>o</B>[<B>ther</B>]:operm | perm[,]] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>u</B>[<B>ser</B>]::operm | perm] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>u</B>[<B>ser</B>]:uid:operm | perm[,...]] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>g</B>[<B>roup</B>]::operm | perm] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>g</B>[<B>roup</B>]:gid:operm | perm[,...]] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>c</B>[<B>lass</B>]:operm | perm] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>o</B>[<B>ther</B>]:operm | perm] 
  <DD>] 
  <DD>[ -d [<B>u</B>[<B>ser</B>]:uid[,...]][<B>g</B>[<B>roup</B>]:gid[,...]] 
  [<B>d</B>[<B>efault</B>]:<B>u</B>[<B>ser</B>]:[,...]] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>u</B>[<B>ser</B>]:uid[,...]] 
  [<B>d</B>[<B>efault</B>]:<B>g</B>[<B>roup</B>]:[,...]] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>g</B>[<B>roup</B>]:gid[,...]] 
  [<B>d</B>[<B>efault</B>]:<B>c</B>[<B>lass</B>]:[,...]] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>o</B>[<B>ther</B>]:[,...]]] 
  <DD>file ... </DD></DL>or
<P>
<DL>setacl [-r] -s <B>u</B>[<B>ser</B>]::operm | perm[,] 
  <DD>[<B>u</B>[<B>ser</B>]:uid:operm | perm[,...]] 
  <DD><B>g</B>[<B>roup</B>]::operm | perm[,] 
  <DD>[<B>g</B>[<B>roup</B>]:gid:operm | perm[,...]] 
  <DD><B>c</B>[<B>lass</B>]:operm | perm [,] 
  <DD><B>o</B>[<B>ther</B>]:operm | perm[,] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>u</B>[<B>ser</B>]::operm | perm] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>u</B>[<B>ser</B>]:uid:operm | perm[,...]] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>g</B>[<B>roup</B>]::operm | perm] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>g</B>[<B>roup</B>]:gid:operm | perm[,...]] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>c</B>[<B>lass</B>]:operm | perm] 
  <DD>[<B>d</B>[<B>efault</B>]:<B>o</B>[<B>ther</B>]:operm | perm] 
  <DD>file... </DD></DL>or
<P>setacl [-r] -f acl_file file
<P>where:
<P>
<DL>
  <DD>operm = octal representation of permissions (Note: for an ACL entry one 
  octal digit is required)
  <P></P>
  <DD>perm = a permissions string composed of the characters r (read). w 
  (write), x (execute/search), or - (no permission). The permission string must 
  be at least 1 character and no more than 3 characters. The characters r. w, 
  and x may only be in the string at most once. The characters may be in any 
  order within the string.
  <P></P>
  <DD>uid = user identity (i.e., login name or user ID)
  <P></P>
  <DD>gid = group identity (i.e., group name or group ID)
  <P></P>
  <DD>When the <B>-f</B> option is specified, it will take the access control 
  information stored in the file <EM>acl_file</EM> and assign it to the file 
  <EM>file</EM>. See the PROCESSING section below for further information on the 
  format of the file <EM>acl_file</EM>.
  <P></P></DD></DL>PROCESSING: A unique ACL will exist for each file on the 
system. There are four types of ACL entries, consisting of <B>user, group, 
class</B>, and <B>other.</B> The <B>user</B> entry for the file owner, the 
<B>group</B> entry for the file owning group, the <B>class</B> entry for the 
file group class, and the entry for <B>other</B> must always be in the ACL.
<P>
<DL>
  <DD>1. <B>user</B> entry - This type of entry contains a user ID and the 
  associated permissions that will be granted to the user. There must always 
  exist one entry of this type, which will represent the file owner, and will be 
  denoted by a null (unspecified) user ID. There may be additional <B>user</B> 
  entries specified; however each entry must specify a unique user ID and there 
  may not be any additional entries with a null user ID. If there is a 
  <B>user</B> entry with a user ID equal to the file owner the file owner entry 
  will take precedence when an access check is performed.
  <P></P>
  <DD>2. <B>group</B> entry - This type of entry contains a group ID and the&lt; 
  associated permissions that will be granted to the group. There must always 
  exist one entry of this type, which will represent the file owning group, and 
  will be denoted by a null (unspecified) group ID. There may be additional 
  <B>group</B> entries specified; however, each entry must have a unique group 
  ID and there may not be any additional entries with a null group ID.
  <P></P>
  <DD>3. <B>class</B> entry - This type of entry contains the maximum 
  permissions for the file group class. There is exactly one of these entries in 
  an ACL.
  <P></P>
  <DD>4. <B>other</B> entry - This type of entry contains the permissions 
  granted to a subject if none of the above entries have been matched. There is 
  exactly one of these entries in an ACL.
  <P></P></DD></DL>When the <EM>setacl</EM> command is used to change the ACL. it 
may result in changes to the file permission bits. Specifically. when the 
<B>user</B> ACL entry for the file owner is modified the file owner class 
permission bits will be modified. When the <B>class</B> ACL entry is modified, 
the file group class permission bits will be modified. When the <B>other</B> ACL 
entry is modified the file other class permission bits will be modified.
<P>When the additional <B>user</B> entries or additional <B>group</B> entries of 
the ACL are modified, the file group class permission bits may also need to be 
modified to reflect the maximum permission allowed by these entries.
<P>The <B>-r</B>, recalculate, option will result in the permissions specified 
in the class entry being ignored and replaced by the maximum permission needed 
for the file group class. For example, if there are no additional <B>user</B> 
entries or additional <B>group</B> entries, the permission of the <B>group</B> 
entry for the file owning group is used for the class entry.
<P>A directory may contain default ACL entries. These entries may be of the type 
<B>default:user, default:group, default:class</B>, or <B>default:other</B>. For 
<B>default:user</B> entries, if no user ID is specified, this entry will apply 
to the file owner permissions. Additional <B>default:user</B> entries must have 
a unique user ID specified. For <B>default:group</B> entries, if no group ID is 
specified, this entry will apply to the file owning group permissions. 
Additional <B>default:group</B> entries must have a unique group ID specified. 
If there are no additional <B>default:user</B> entries or additional 
<B>default:group</B> entries, then the permissions of the <B>default:group</B> 
and the <B>default:class</B> must be the same.
<P>If a file is created in a directory which contains default ACL entries the 
entries will be added to the newly created file. Note that the default 
permissions specified for the file owner class, file group class, and file other 
class will be constrained by the <B>umask</B> and the mode( specified in the 
file creation call. If default ACL entries are specified for a file which is not 
a directory the command will fail {11}, see <B>ERRORS AND RETURNS</B>.
<P>With no options and arguments {1}, see <B>ERRORS AND RETURNS</B>. If the MAC 
or DAC check fails when a request is made to modify the ACL (2), see <B>ERRORS 
AND RETURNS</B>. If the file named file does not exist {6}, see <B>ERRORS AND 
RETURNS</B>.
<P>If options are specified, the validity of the option-arguments will be 
checked. If an invalid option is specified {3a}, see <B>ERRORS AND RETURNS</B>. 
The arguments must be processed in the order specified (e.g., if the modify 
option is specified with a user, followed by the delete option with ihe same 
user, the entry will be deleted).
<P>For the <B>-m</B>, <B>-s</B>, and <B>-d</B> options, if uid is not a valid 
login name or a valid user ID {3b}, or if gid is not a valid group name or a 
valid group ID {3c}, or if a specified perm is not r, w, x, -, or a specified 
operm is not an octal digit {3d}, see <B>ERRORS AND RETURNS</B>.
<P>The <B>-m</B> option is used to add a new ACL entry or change an existing ACL 
entry.
<P>If an entry already exists for the specified uid or gid. the specified 
permissions (perm operm) will replace the current permissions. If an entry does 
not exist for the specified uid or gid, an entry will be created. Note that an 
entry with no permissions will result in the specified uid or gid being denied 
access (any permissions) to the file. To specify no access in an entry being 
modified or added, either 0 should be specified for operm or - should be 
specified for perm.
<P>The <B>-s</B> option is used to replace the ACL information on a file. The 
effect of using this option is that all entries are removed, and replaced by the 
newly specified ACL. If -s is specified with -d, -f, or -m {5}, see <B>ERRORS 
AND RETURNS</B>. There must be exactly one <B>user</B> entry specified for the 
file owner, exactly one <B>group</B> entry specified for the file owning group, 
exactly one <B>class</B> entry specified for the file group class, and exactly 
one <B>other</B> entry specified. If there is no user entry specified for the 
file owner. or no group entry specified for the file owning group or no class 
entry specified for the file group class, or no other entry specified {8}, see 
<B>ERRORS AND RETURNS</B>. There may be additional user ACL entries and 
additional group ACL entries specified. If duplicate entries are specified {9}, 
see <B>ERRORS AND RETURNS</B>.
<P>The <B>-d</B> option is used to delete an existing entry from the ACL. If a 
matching entry is not found {4a}, see <B>ERRORS AND RETURNS</B>. Otherwise, the 
matching entry will be deleted. The <B>user</B> entry for the file owner, the 
<B>group</B> entry for the file owning group, the <B>class</B> entry, and the 
<B>other</B> entry may not be deleted from the ACL. If an attempt is made to 
delete one of these entries {4b}, see <B>ERRORS AND RETURNS</B>.
<P>(Note: deleting an entry may have different effects than removing all the 
specified permissions for an entry. If an entry is deleted and a search is later 
done for the user or group identity that appeared in the entry, this identity 
might match another entry and then be given the permissions specified in this 
other entry. If the original entry remained with no permissions and a search was 
done for this identity. the search might match this entry and the subject would 
be denied access.)
<P>The <B>-f</B> option is used to assign the ACL information contained in the 
file named <EM>acl_file</EM> to the specified file(s). If -f is specified with 
-d. -s. or -m {5}, see <B>ERRORS AND RETURNS</B>. If the file named 
<EM>acl_file</EM> does not exist {6}, see <B>ERRORS AND RETURNS</B>. The file 
named <EM>acl_file</EM> must be readable by the invoking subject. If it is not 
readable {2}, see <B>ERRORS AND RETURNS</B>.
<P>If the entire file named <EM>acl_file</EM> contains correct external 
representation(s) for ACL entries, the ACL for the specified file(s) will be 
(removed and) replaced with the ACL whose external representation is contained 
in the file named <EM>acl_file</EM>. Each external representation of an ACL 
entry, contained in the file named <EM>acl_file</EM>, must be on a separate line 
and must be in the following format:
<P>
<DL>
  <DD>u[ser]::operm perm 
  <DD>[u[ser]:uid:operm perm] 
  <DD>g[roup]::operm perm 
  <DD>[g[roup]:gid:operm perm] 
  <DD>c[lass]:operm perm 
  <DD>o[ther]:operm perm 
  <DD>[d[efault]:u[ser]::operm perm] 
  <DD>[d[efault]:u[ser]:uid:operm perm[,...]] 
  <DD>[d[efault]:g[roup]::operm perm] 
  <DD>[d[efault]:g[roup]:gid:operm perm[,...]] 
  <DD>[d[efarnlt]:c[lass]:operm perm] 
  <DD>[d[efault]:o[ther]:operm perm] </DD></DL>The entries are not required to be 
in any specific order within the file.
<P>There must be exactly one <B>user</B> entry specified for the file owner, 
exactly one <B>group</B> entry specified for the file owning group, exactly one 
<B>class</B> entry specified for the file group class, and exactly one 
<B>other</B> entry specified. If not, see <B>ERRORS AND RETURNS</B>. There may 
be additional user ACL entries and additional group ACL entries specified. If 
duplicate entries are specified {9}, see <B>ERRORS AND RETURNS</B>.
<P>Validity checks are performed on all entries. If an invalid entry is 
encountered {7}; see <B>ERRORS AND RETURNS</B>. If the exact problem can be 
determined an additional message may be displayed {3b}{3c}{3d}, see <B>ERRORS 
AND RETURNS.</B>
<P>The character "#" will be used to indicate a comment. All characters starting 
with the #. to the end of the line will be ignored. Note that this includes any 
effective permissions (#effective:rwx) displayed by <B>getacl</B>.
<P>This command may be executed on a file system that does not support ACLs. If 
ACL entries are specified which do not map into the base permissions {10}, see 
<B>ERRORS AND RETURNS</B>, otherwise the base permissions will be set.
<P>ERRORS AND RETURNS: Following is a list of error conditions and the 
corresponding error message that should be output when this condition occurs. 
<P>
<DL>usage: setacl [-r] [ -m [rn(ser]::operm perm[.]] 
  <DD>[rn[ser]:uid:operm perm[,...J] 
  <DD>[g[roup]::operm perm[,]] 
  <DD>[g[roup]:gid:operm perm[....]] 
  <DD>[c[lass]:operm perm[,]] 
  <DD>[o[ther]:operm perm[,]] 
  <DD>[d(efault]:u[ser]::operm perm] 
  <DD>(d(efarnlt]:u[ser]:uid:operm perm(9...]] 
  <DD>[d[efault]:g[roup]::operm perm] 
  <DD>[d[efault]:g[roup]:gid:operm perm[,...]] 
  <DD>[d[efault]:c[lass]:operm perm] 
  <DD>[d[efault]:o[ther]:operm perm] 
  <DD>] 
  <DD>-d [u[ser]:uid[,...]][g[roup]:gid(,...]] [d 
  <DD>[efault]:u(ser]:] 
  <DD>fd [efault]:u[ser]:uid[,...]] [d[efault]:g[roupj:[,...]] 
  <DD>[d[efault]:g(roup]:gid] [d[efarnlt]:o[ther]:]] 
  <DD>file... </DD></DL>or
<P>
<DL>setacl [-r] -s rn(ser]::operm perm[,] 
  <DD>[rn[ser']:uid:operm perm[,...]] 
  <DD>g[roup]::operm perm(.] 
  <DD>[g[roup]:gid:operm perm[,...]] 
  <DD>c[lass]:operm perm[,] 
  <DD>o[ther]:operm perm[,] 
  <DD>[d[efault]:u[ser]::operm perm] 
  <DD>[d[efault]:u[ser]:uid:operm perm[9...]] 
  <DD>[d[efault]:g[roup]::operm perm] 
  <DD>[d[efault]:g[roup]:gid:operm perm[....]] 
  <DD>[d[efault]:c[lass]:operm perm] 
  <DD>[d[efault]:o[ther]:operm \\perm] 
  <DD>file </DD></DL>or
<P>setacl [-r] -f acljile file
<P>{1} No options or arguments:
<P>
<DL>
  <DD>UX:setacl: ERROR: incorrect usage 
  <DD>usage: ... </DD></DL>{2} If MAC or DAC check fails on the specified file:
<P>
<DL>
  <DD>UX:setacl: ERROR: permission denied for "<EM>filename</EM>" </DD></DL>{3} 
invalid option-arguments: 
<DL>
  <DD>{a} incorrect/unknown option specified: 
  <DL>
    <DD>UX:setacl: ERROR: illegal option -- "-option" 
    <DD>usage: ... </DD></DL>
  <DD>{b} invalid user ID: 
  <DL>
    <DD>UX:setacl: ERROR: unknown user-id "uid" </DD></DL>
  <DD>{c} invalid group ID: 
  <DL>
    <DD>UX:setacl: ERROR: unknown group-id "gid" </DD></DL>
  <DD>{d} invalid permission: 
  <DL>
    <DD>UX:setacl: ERROR: unknown permission "permission" 
    <DD>usage: ... </DD></DL></DD></DL>{4}invalid attempt to delete an ACL entry:
<P>
<DL>
  <DD>{a} attempt to delete a non-existent entry from an ACL: 
  <DL>
    <DD>UX:setacl: ERROR: matching entry not found in ACL </DD></DL>
  <DD>{b} attempt to delete file owner, file owning group. class. or other ACL 
  entries: 
  <DL>
    <DD>UX:setacl: ERROR: file owner, file group, "class". and "other" entries 
    may not be deleted </DD></DL></DD></DL>{5} the options specified are mutually 
exclusive: 
<DL>
  <DD>UX:setacl: ERROR: incompatible options specified usage: </DD></DL>{6} 
filename does not exist: 
<DL>
  <DD>UX:setacl: ERROR: file `file,name" not found </DD></DL>{7} an invalid ACL 
entry encountered in the file acl_file: 
<DL>
  <DD>UX:setacl: ERROR: "acl_file", line line; invalid ACL entry </DD></DL>{8} 
required entry for file owner, file owning group, class, or other missing: 
<DL>
  <DD>UX:setacl: ERROR: required entry for file owner, file group, "class", or 
  "other" not specified 
  <DD>usage: ... </DD></DL>{9} duplicate ACL entries specified: 
<DL>
  <DD>UX:setacl: ERROR: duplicate entries: "acl,entry" </DD></DL>{10} the file 
system does not have ACLs, and additional entries are specified: 
<DL>
  <DD>UX:setacl: ERROR: only file owner, file group, "class" or "other" entries 
  may be specified </DD></DL>{11} the specified file is not a directory, and 
default entries have been specified: 
<DL>
  <DD>UX:setacl: ERROR: default ACL entries may only be set on directories 
</DD></DL>OUTPUT: None
<P>
<H2>A.2.2 getacl Command</H2>DESCRIPTION: The getacl command will support (he 
displaying of discretionary
<P>information associated with a file. It will allow the file owner or a
<P>process with appropriate permission or appropriate privilege to
<P>perform the following functions:
<P>1. display the owner, group, and ACL for the specified file(s),
<P>2. display the default ACL for a directory.
<P>Note that this command only supports the file system objects: e.g.,
<P>regular files, special files, directories. and named pipes. For
<P>simplicity, these objects are referred to as "files".
<P>SYNOPSIS:
<P>getacl [-ad] file
<P>PROCESSING: With no arguments (1), see <B>ERRORS AND RETURNS. If MAC or</B>
<P>DAC check fails when a request is made to display the ACL information
<P>(2) see <B>ERRORS AND RETURNS</B>. With invalid options (3), see ERRORS AND
<P>RETURNS. If the file named file does not exist (4), see ERRORS AND
<P>RETURNS.
<P>With the <B>-a option specified, the filename, owner, group, and the ACL 
of</B>
<P>the file will be displayed. With the <B>-d option specified, the 
filename,</B>
<P>owner, group, and the default ACL of the file will be displayed, if it
<P>exists. If the specified file does not support default ACLs (e.g., it is not 
a
<P>directory) only the filename, owner, and group will be displayed. With
<P>no option specified, both the ACL and the default ACL (if it exists) of the 
<P>file will be displayed.
<P>This command may be executed on a file system that does not support
<P>ACLs. It will report the ACL based on the base permission bits.
<P><B>ERRORS AND RETURNS: Following is a list of error conditions and the</B>
<P>corresponding error message that should be output when this condition
<P>occurs.
<P>
<P>usage: getacl [-ad] file
<P>(1) No arguments:
<P>UX:getacl: ERROR: incorrect usage
<P>usage:...
<P>(2) If MAC or DAC check fails when a request is made to display the ACL
<P>information:
<P>UX:getacl: ERROR: permission denied for "file"
<P>
<P>(3) incorrect/unknown option specified:
<P>UX:getacl: ERROR: illegal option -- "-optio,t"
<P>usage:...
<P>
<P>(4) file does not exist:
<P>UX:setacl: ERROR: file "file" not found
<P>OUTPUT: When an ACL is displayed, the external representation of the ACL will
<P>be as follows:
<P># file: filename
<P># owner: uid
<P># group: gid
<P>user::perm
<P>inser:uid:perm
<P>group::perm
<P>group:gid:perm
<P>class:perm
<P>other:perm
<P>default :user: :perm
<P>default :user:uid:perm
<P>defai,lt :group: :perm
<P>default :group :gid :perm
<P>default :class :perm
<P>default :other :perm
<P>The ACL entries will be displayed in the order listed above (the user
<P>entry for the file owner, followed by zero or more additional user
<P>entries, followed by the group entry [or the file owning group, followed
<P>by zero or more additional group entries, followed by the class entry
<P>for the file group class, followed by the entry for other). When the
<P>specified file is a directory the entries described above may be
<P>followed by default entries (the default user entry for the file
<P>owner, followed by zero or more additional default:user entries,
<P>followed by the default:group entry for the file owning group,
<P>followed by zero or more additional default:group entries, followed
<P>by the default:class entry for the file group class, followed by the
<P>entry for default:other). Note that these default ACL entries are
<P>never used in an access check.
<P>If more than one file is specified, a blank line will be displayed
<P>before the ACL of the next file is displayed.
<P>The first line displays the name of the file, next the file owner, and then 
the file owning group. The user entry without a user ID indicates the 
permissions that will be granted to the owner of the file. The additional user 
entries indicate the permissions that will be granted to the specified user. The 
group entry without a group indicates the permissions that will be granted to 
the group of the file. The additional group entries indicate the permissions 
that will be granted to the specified group. The class entry indicates the 
permissions that will be granted to the file group class. The other entry 
indicates the permissions that will be granted to others.
<P>The default entries (default:user, default:group, default:class, and 
default:other) may only exist for directories, and indicate the default user, 
group, class, and other entries respectively that will be merged with the ACL 
for a new file created within the directory.
<P>The uid is a login name, or a user ID (only if there is no login name 
associated with the user ID); gid is a group name. or a group ID (only if there 
is no group name associated with the group ID); and perm is a three character 
string composed of the letters representing the separate discretionary access 
controls, r (read). w (write), x (execute/search), or the character -. The perm 
will be displayed in the following order: rwx. If a permission is not granted by 
this ACL entry. the placeholder. "-", will appear. For example. if the user does 
not have write permission. but does have read and execute permission, r-x will 
be output.
<P>The file group class permission bits constrain the ACL (represent the most 
access that any entry in the ACL may have). If a user executes the chmod command 
and changes the file group class permission bits this may change the permissions 
that would be granted based on the ACL alone. This behavior is necessary for the 
save-restore model (all permissions are temporarily removed via <B>chmod 000 
file and then restored) to work correctly. In order to indicate that the file 
permission bits are more restrictive than an ACL entry, getacl will display the 
ACL entry as described above with an additional tab followed by a sharp sign and 
the effective permissions.</B>
<P>Note that output from getacl will be in the correct format for input to 
setacl. Therefore, if the output is redirected into a file (e.g., getacl junk 
&gt; entries), this file can be used as input to setacl (e.g., setacl -f entries 
junk.new). In this way, a user can easily assign one file's ACL information to 
another file.
<P>EXAMPLES:
<P>1) File with several ACL entries:
<P>#file:fred
<P>#owner:craig
<P># group: demo
<P>user::rwx
<P>user:spy:---
<P>user:larry:rw-
<P>group::r--
<P>class:rw-
<P>other:---
<P>2) Same file. after a "chmod 700 fred":
<P>#file:fred
<P>$ owner: craig
<P>$ group: demo
<P>user::rwx
<P>user:spy:---
<P>user:larry:rw- #effective:---
<P>group::r-- $effective:---
<P>class:---
<P>other:---
<P>3) Directory with ACL entries including default ACL entries:
<P>$ file: foodir
<P>$ owner: craig
<P>$ group: demo
<P>user::rwx
<P>user:spy:---
<P>user:larry:rwx
<P>group::r-x
<P>class:rwx
<P>other:r--
<P>default:user::rwx
<P>default user :larry :rwx
<P>default:rnser:worm:- --
<P>default :group:demo:r -
<P>default:other:---
<P>
<UL>
  <H2>2.3 acl Function</H2></UL>DESCRIPTION: The act call will support the getting 
and setting of
<P>discretionary permission information associated with a file. It will
<P>allow the file owner or a process with appropriate permission or
<P>appropriate privilege to perform the following functions:
<P>1. get or set a file's ACL information in an atomic operation.
<P>2. return the number of entries contained in an file's ACL.
<P>Note that this call only supports the file system objects: e.g., regular
<P>files, special files, directories, and named pipes. For simplicity,
<P>these objects are referred to as "files".
<P>SYNOPSIS:
<P>#include &lt;tbd.h&gt;
<P>int acl(const char *path, int cmd. int nentries, struct acl "aclbufp)
<P>Three values for cmd will be supported: ACLSET, ACLGET, and ACL_CNT.
<P>The value of nentries is the number of ACL entries that can fit in the
<P>user-supplied ACL buffer for an ACL_GET or the number actually present
<P>for an ACL_SET; and aclbufp is a pointer to the user-supplied buffer of
<P>ACL entry structures. The buffer will consist of an array of four
<P>(USER_OBJ, GROUP_OBJ, CLASS_OBJ, and OTHER_OBJ entries are required) or
<P>more occurrences of the following structure:
<P>struct acl [
<P>int a_type;
<P>uid_t a_id;
<P>ushort a_perm;
<P>];
<P>Twelve values of a_type will be supported to specify the type of entry:
<P>(six for access checking and six for defaults), USER_OBJ, USER,
<P>GROUP_OBJ, GROUP, CLASS_OBJ, OTHER_OBJ, DEF_USER_OBJ, DEF_USER,
<P>DEF_GROUP_OBJ, DEF_GROUP, DEF_CLASS_OBJ, and DEF_OTHER_OBJ.
<P>When a_type is USER or DEF_USER, aid will be a user id, and when a_type
<P>is GROUP or DEF_GROUP, aid will be a group id. When a_type is USER_OBJ,
<P>GROUP_OBJ, CLASS_OBJ, OTHER_OBJ, DEF_USER_OBJ,
<P>DEF_GROUP_OBJ, DEF_CLASS_OBJ, or DEF_OTHER_OBJ, a_id will not be
<P>used. The permissions for the entry will be contained in a_perm.
<P>PROCESSING: When the specified cmd is <B>ACL_CNT, the return value from the 
call</B>
<P>will be the number of ACL entries for the filename pointed to by path.
<P>The values of nentries and aclbitfp will be ignored. If the user does
<P>not pass the DAC and MAC checks to see the ACL. the acl call will fail
<P>(see <B>ERRORS AND RETURNS).</B>
<P>When the specified cmd is <B>ACL_GET. the ACL information for the 
filename</B>
<P>pointed to by path will be retrieved and the ACL entries will be
<P>placed in the buffer pointed to by aclbufp. The value of nentries is
<P>the number of entries that can be held in the allocated buffer. If
<P>the number of ACL entries in the ACL is greater than the value of
<P>nentries (that is. the buffer space allocated to hold the files ACL
<P>entries is less than nentries times the size of an entry), the acl
<P>call will fail (see <B>ERRORS AND RETURNS). On success. the return value</B>
<P>from this call will be the number of ACL entries retrieved. On any
<P>error, the contents of the acl structures pointed to by aclbufp are
<P>indeterminate. If the user does not pass the DAC and MAC checks to see
<P>the ACL, the acl call will fail (see <B>ERRORS AND RETURNS).</B>
<P>When the specified cmd is <B>ACL_SET, ACL entries currently in the buffer</B>
<P>pointed to by aclbufp, for the filename pointed to by path, will be
<P>set if all required checks are passed. The contents of nentries shall be
<P>the number of ACL entries in the buffer, pointed to by aclbufp, to be
<P>copied. On success, the return value from this call will be 0. If the
<P>invoking user does not pass the DAC and MAC checks to set an ACL, the
<P>act call will fail (see <B>ERRORS AND RETURNS). If an error occurs,</B>
<P>either due to DAC and MAC checks or the validation check listed below,
<P>there will be no change to the current ACL information. Before the ACL
<P>entries are actually set, validation checks will be performed to
<P>determine that the ACL entries are in the following order:
<P>a) a user entry for the file owner (<B>USER_OBJ),</B>
<P>
<P>b) additional user entries (<B>USER),</B>
<P>
<P>c) a group entry for the file owning group (<B>GROUP_OBJ),</B>
<P>
<P>d) additional group entries (<B>GROUP),</B>
<P>
<P>e) a class entry for the file group class (<B>CLASS_OBJ),</B>
<P>
<P>f) an entry for other (<B>OTHER_OBJ),</B>
<P>
<P>g) default user entry for the file owner (<B>DEF_USER_OBJ),</B>
<P>
<P>h) default additional user entries (<B>DEF_USER),</B>
<P>i) default group entry for the file owning group (<B>DEF_GROUP_OBJ),</B>
<P>j) default additional group entries (<B>DEF_GROUP),</B>
<P>k) default class entry for file group class (<B>DEF_CLASS_OBJ).</B>
<P>l) default entry for other (<B>DEF_OTHER_OBJ),</B>
<P>The entry in classes a), c), e), and f) must always exist. The entry for 
classes a), c), e), f), g), i), k), and l) do not use the a_id field. Classes b) 
and h) may contain zero or more entries and the entries must be sorted by uid 
(lowest to highest). Classes d) and j) may contain zero or more entries and the 
entries must be sorted by gid (lowest to highest). (this ordering should be done 
with the aclsort function).
<P>Class g), h), i), j), k), and l) entries are only applicable for directories. 
If an attempt is made to set default ACL entries on a file that is not a 
directory, the call will fail (see <B>ERRORS AND RETURNS).</B>
<P>Validation of the ACL will be performed. If entries containing duplicate uids 
or gids are found, or there is not exactly one <B>user entry specified for the 
file owner, one group entry specified for the file owning group, one class entry 
specified for the file group class, and one other entry specified, or there are 
no additional user and group entries and the permissions of the class entry are 
not equal to the permissions of the group entry, or there are no additional 
default:user and default:group entries and the permissions of the default:class 
entry is not equal to the permissions of the default:group entry, the call will 
fail (see <B>ERRORS AND RETURNS</B>).</B>
<P>The file owner class permission bits will be changed, such that they are 
equal to the permissions specified for the <B>user entry of the file owner in 
the ACL. The file group class permission bits will be changed, such that they 
are equal to the permissions specified for the class ACL entry. The file other 
class permission bits will be changed, such that they are equal to the 
permissions specified for the other ACL entry.</B>
<P>This function may be executed on a file system that does not support ACLs. 
With ACL_GET as the cmd it will report the ACL based on the file permission 
bits. With ACL_SET as the cmd, if ACL entries are specified which do not map 
into the file permission bits, see <B>ERRORS AND RETURNS, otherwise the file 
permission bits will be set.</B>
<P>A design may constrain the maximum number of ACL entries that are written, 
with a system-wide tunable parameter, <B>aclmax. If the number ofACL entries 
exceeds the value of aclmax the function will fail (see <B>ERRORS AND 
RETURNS</B>).</B>
<P>ERRORS AND RETURNS: If the acl call is unsuccessful, a value of <B>-l will 
be</B>
<P>returned and errno will be set to indicate the error. Only
<P>implementation-independent errnos are presented.
<P>Under the following conditions, the function act will fail and will
<P>set errno to the specified value (note: unless otherwise stated, the
<P>errno applies to ACL_CNT, ACL_GET, and ACL_SET):
<P>ENOTDIR if a component of the path prefix is not a directory
<P>ENOTDIR if an attempt is made to set a default ACL on a file
<P>type other than a directory
<P>ENOENT if a component of the pathname should exist but does not
<P>EACCES if the DAC and/or MAC check fails
<P>EINVAL if cmd is not ACL_CNT, ACL_GET, or ACL_SET
<P>EINVAL if cmd is ACL_SET and the ACL entries do not pass the
<P>validation check
<P>ENOSPC if cmd is ACLGET and the space required for the
<P>file's ACL entries exceeds nentries
<P>ENOSPC if cmd is ACL,SET and there is insufficient space
<P>in the file system to store the ACL
<P>EINVAL if the number of acl entries exceeds the value of <B>aclmax</B>
<P>ENOSYS if the file system type does not support ACLs, and
<P>additional entries are specified
<P>
<UL>
  <H2>2.4 aclsort Function</H2></UL>DESCRIPTION: The aclsort function will take as 
input a buffer containing ACL
<P>entries (including default ACL entries) and sort them into the correct
<P>order to be accepted by the act or the aclipc function. It will
<P>optionally calculate the maximum permissions needed for the object group
<P>class and set the <B>class ACL entry.</B>
<P>SYNOPSIS:
<P>$include &lt;tbd.h&gt;
<P>int aclsort(int nentries, int calclass, struct acl *aclbufp)
<P>Where the value of nentries is the number of ACL entries, the value of
<P>calclass if non-zero indicates to recalculate the <B>class entry, and</B>
<P>aclbufp is a pointer to ACL entry structures.
<P>PROCESSING: A call to aclsort will result in the contents of the buffer
<P>being sorted in the following order:
<P>a) a user entry for the object owner,
<P>b) additional user entries.
<P>c) a group entry for the object owning group,
<P>d) additional group entries,
<P>e) a class entry for the file group class,
<P>f) an entry for other,
<P>g) default user entry for the object owner.
<P>h) default additional user entries,
<P>i) default group entry for the object owning group.
<P>j) default additional group entries,
<P>k) default class entry for the file group class,
<P>l) default entry for other.
<P>Classes a), c), e), and f) must each have exactly one entry, if not,
<P>see <B>ERRORS AND RETURNS. Classes g), i), k), and l) must have zero or</B>
<P>one entry, if not, see <B>ERRORS AND RETURNS. Entries will be sorted in</B>
<P>increasing order, by user ID in classes b) and h), and by group ID in
<P>classes d) and j). Following sorting, a check will be performed to verify 
that no
<P>duplicate entries (more than one entry containing the same user ID or the 
same
<P>group ID) exist. If duplicate entries are found, see <B>ERRORS AND 
RETURNS.</B>
<P>If there are no entries in classes b) and d). the function will set
<P>the permission field, a_perm. in the class entry e) to that of the group
<P>entry c). If there are entries in classes b) or d) and the calclass
<P>argument is non-zero, the function will set the permission field,
<P>a_perm, of the <B>class entry to the maximum permission of the entries in</B>
<P>the file group class. Otherwise, the <B>class entry permissions will 
remain</B>
<P>unchanged.
<P>If there are no entries in classes h) and j), the function will set
<P>the permissions in the default class entry k) to that of the default
<P>entry i).
<P>Upon success. aclsort will return the value 0.
<P>ERRORS AND RETURNS: If the aclsort function is unsuccessful due to duplicate
<P>entries, the return value will be the position (entry number) of the 
<P>first duplicate entry. If there is less than one <B>user entry for the</B>
<P>object owner, <B>group entry for the object owning group, class entry for</B>
<P>the file group class, or <B>other entry specified, a value of -l will be</B>
<P>returned. If there is more than one <B>user entry for the object owner,</B>
<P><B>group entry for the object owning group, class entry for the file</B>
<P>group class, or <B>entry specified, they will be treated as duplicate</B>
<P>entries, and the return value will be the position of the duplicate
<P>entry.
<P>If the aclsort function is unsuccessful for any other reason, a value of
<P><B>-l will be returned.</B>
<P>
<UL>
  <H2>2.5 chmod Function</H2></UL>DESCRIPTION: The chmod function supports the 
following functionality:
<P>1. it allows a subject to change the file mode. including the
<P>permissions for the file owner class. the file group class, and the
<P>file other class of a file.
<P>Note that the chmod command will not require any modifications.
<P>SYNOPSIS: No change.
<P>PROCESSING: Any permissions changes made with the chmod command or function
<P>will update the file permission bits. This includes changing the file
<P>owner ACL entry, the <B>class ACL entry, and the other ACL entry if</B>
<P>the corresponding group(s) of bits are changed by this call. Any
<P>additional ACL entries will not be affected. Note. the permissions
<P>granted by such additional entries are constrained by the file group
<P>class permission bits. If no additional <B>user and no additional group</B>
<P>entries exist, the file <B>group class permission bits will also</B>
<P>represent the permissions for the owning group of the file.
<P>ERRORS AND RETURNS: No change.
<P>OUTPUT: No change.
<P>
<UL>
  <H2>2.6 chown Function</H2></UL>DESCRIPTION: The chown function supports the 
following functionality:
<P>1. it allows a subject to change the owner and/or group of a file.
<P>Note that the chown system call/command and the chgrp command will not
<P>require any modifications.
<P>SYNOPSIS: No change.
<P>PROCESSING: When the owner of a file is changed, the result will be identical
<P>to the current behavior. If the owner is changed to a user ID. for
<P>which an additional <B>user entry already exists in the ACL, the 
additional</B>
<P><B>user entry is not changed but the user entry for the file owner will</B>
<P>take precedence during an access check. When the group of a file is
<P>changed. the result will be identical to the current behavior. If the
<P>group is changed to a group ID, for which an additional <B>group entry</B>
<P>already exists in the ACL, the additional <B>group entry is not changed 
but</B>
<P>the <B>group entry for the file owning group will take precedence during 
an</B>
<P>access check (except in the case of multiple concurrent groups, where
<P>all group entries are given equal treatment).
<P>ERRORS AND RETURNS: No change.
<P>OUTPUT: No change.
<P>EXAMPLES: The following examples illustrate the operation of the chown
<P>function. For each example, there is a "before" state showing the
<P>output of getacl, the chown function that is executed, and the "after"
<P>state output.
<P>EXAMPLE 1:
<P>BEFORE:
<P>$ file: filel
<P>$ owner: larry
<P>$ group: guest
<P>user::rwx
<P>group::r--
<P>class:r- -
<P>other:---
<P>CALL: chown(filel, lisa, demo)
<P>AFTER:
<P>$file:filel
<P>$ owner: lisa
<P>$ group: demo
<P>user::rwx
<P>group::r--
<P>class:r--
<P>other:---
<P>EXAMPLE 2:
<P>BEFORE:
<P>$ file: file2
<P>$ owner: tarry
<P>$ group: guest
<P>user::rwx
<P>user:fred:r--
<P>group::r--
<P>group:dev:r--
<P>class:r--
<P>other:---
<P>CALL: chown(file2. lisa demo)
<P>AFTER:
<P>$ file: file2
<P>$ owner: lisa
<P>$ group: demo
<P>user::rwx
<P>user:fred:r---
<P>group::r--
<P>group:dev:r--
<P>class:r--
<P>other:---
<P>EXAMPLE 3:
<P>BEFORE:
<P>$ file: file3
<P>$ owner: larry
<P>$ group: guest
<P>user::rwx
<P>user:lisa:r--
<P>user:fred:r--
<P>group::r--
<P>group:dev:r--
<P>group:demo:r--
<P>class:r--
<P>other:---
<P>CALL: chown(file3. lisa, demo)
<P>AFTER:
<P>$ file: file3
<P>$ owner: lisa
<P>$ group: demo
<P>user::rwx
<P>user:lisa:r--
<P>user:fred:r--
<P>group::r--
<P>group:dev:r--
<P>group:demo:r--
<P>class:r--
<P>other:---
<P>Note in EXAMPLE 3, a <B>user entry contains a user ID that is the same as the 
file owner. In this case the file owner entry takes precedence. Also in EXAMPLE 
3, a group entry contains a group ID that is the same as the owning group of the 
file. If multiple concurrent groups are not being used, the object owning group 
entry takes precedence.</B>
<P>
<UL>
  <H2>2.7 aclipc Function</H2></UL>DESCRIPTION: The aclipc call will support the 
getting and setting of
<P>discretionary permission information associated with an IPC object. It
<P>will allow the object owner or a process with appropriate permission
<P>or appropriate privilege to perform the following functions:
<P>1. get or set an IPC object's ACL information in an atomic operation.
<P>2. return the number of entries contained in an IPC object's ACL.
<P>Note that this call only supports the IPC objects: e.g., shared memory
<P>segments. semaphores. and message queues. For simplicity, these
<P>objects are referred to as "IPC objects" in the remainder of this
<P>description.
<P>SYNOPSIS:
<P>#include &lt;tbd.h&gt;
<P>int aclipc(int type, int id, int cmd, int nentries, struct acl
<P>*aclbufp)
<P>Three values for type will be supported: <B>IPC_SHM, IPC_SEM, and 
IPC_MSG.</B>
<P>If type is <B>IPC_SHM, id must be a valid shmid returned by shmget. If 
type</B>
<P>is <B>IPC_SEM, id must be a valid semid returned by semget. If type is</B>
<P><B>IPC_MSG, id must be a valid msgid returned by msgget. Three values for</B>
<P>cmd will be supported: <B>ACL_SET. ACL_GET, and ACL_CNT. The value of</B>
<P>nentries is the number of ACL entries that can fit in the user
<P>-supplied ACL buffer for an <B>ACL_GET or the number actually present for</B>
<P>an <B>ACL_SET; and aclbufp is a pointer to the user-supplied buffer of 
ACL</B>
<P>entry structures. The buffer will consist of an array of four
<P>(<B>USER_OBJ, GROUP_OBJ, CLASS_OBJ, and OTHER_OBJ entries are required)</B>
<P>or more occurrences of the following structure:
<P>struct acl {
<P>int a_type;
<P>uid_t a_id;
<P>ushort a_perm;
<P>};
<P>Six values of a_type will be supported to specify the type of entry:
<P><B>USER_OBJ, USER, GROUP_OBJ, GROUP, CLASS_OBJ, and OTHER_OBJ.</B>
<P>When a_type is <B>USER, a_id will be a user id, and when a_type is GROUP,</B>
<P>a_id will be a group id. When a_type is <B>USER_OBJ, GROUP_OBJ, 
CLASS_OBJ,</B>
<P>or <B>OTHER_OBJ, a_id will not be used. The permissions for the entry 
will</B>
<P>be contained in a_perm.
<P>PROCESSING: When the specified cmd is <B>ACL_CNT, the return value from the 
call</B>
<P>will be the number of ACL entries for the IPC object specified by type
<P>and id. The values of nentries and aclbufp will be ignored. If the
<P>invoking user does not pass the DAC or MAC checks to see the ACL. the
<P>aclipc call will fail (see <B>ERRORS AND RETURNS).</B>
<P>When the specified cmd is <B>ACL_GET the ACL information for the IPC 
object</B>
<P>specified by type and id will be retrieved and the ACL entries will be
<P>placed in the buffer pointed to by aclbufp. The value of nentries is
<P>the number of entries that can be held in the buffer. If the number of
<P>ACL entries in the ACL is greater than the value of nentries (the buffer
<P>space allocated to hold the file's ACL entries is less than nentries
<P>times the size of an entry), the aclipc call will fail (see <B>ERRORS AND</B>
<P><B>RETURNS). On success. the return value from this call will be the 
number</B>
<P>of ACL entries retrieved. On any error, the contents of the <B>acl</B>
<P>structures pointed to by aclbufp are indeterminate. If the user does
<P>not pass the DAC and MAC checks to see the ACL, the aclipc call will
<P>fail (see <B>ERRORS AND RETURNS).</B>
<P>
<P>When the specified cmd is <B>ACL_SET, ACL entries currently in the 
buffer,</B>
<P>pointed to by aclbufp, for the IPC object specified by type and id, will
<P>be set if all required checks are passed. The contents of nentries shall
<P>be the number of ACL entries in the buffer pointed to by aclbufp to be
<P>copied. On success, the return value from this call will be 0. If the
<P>invoking subject does not pass the DAC and MAC checks to set an ACL the
<P>aclipc call will fail (see <B>ERRORS AND RETURNS). If an error occurs,</B>
<P>either due to DAC or MAC checks or the validation check listed below,
<P>there will be no change to the current ACL information. Before the ACL
<P>entries are actually set, validation checks will be performed to
<P>determine that the ACL entries are in the following order:
<P>a) a user entry for the IPC object owner (<B>USER_OBJ),</B>
<P>b) additional user entries (<B>USER),</B>
<P>c) a group entry for the IPC object owning group (<B>GROUP_OBJ),</B>
<P>d) additional group entries (<B>GROUP),</B>
<P>e) a class entry for the IPC group class (<B>CLASS_OBJ),</B>
<P>f) an entry for other (<B>OTHER_OBJ).</B>
<P>The entries in class a), c), e), and f) must always exist. The entry
<P>for class a), c), e), and f) do not use the aid field. Class b) may
<P>contain zero or more entries and the entries must be sorted by <B>uid 
(lowest</B>
<P>to highest). Class d) may contain zero or more entries and the entries must 
be
<P>sorted by gid (lowest to highest). (this ordering should be done with the 
aclsort
<P>function).
<P>
<P>Validation of the ACL will be performed. If entries containing duplicate
<P>uids or gids are found. or there is not exactly; one <B>user entry for</B>
<P>the object owner, one <B>group entry for the object owning group. one 
class</B>
<P>entry for the IPC group class, or one <B>other entry specified. or there</B>
<P>are no additional user and <B>group entries and the permissions of the</B>
<P><B>class entry are not equal to the permissions of the group entry, the</B>
<P>call will fail (see <B>ERRORS AND RETURNS).</B>
<P>
<P>The IPC owner permission bits will be changed, such that they are
<P>equal to the permissions specified for the <B>user entry of the object</B>
<P>owner in the ACL. The IPC group class permission bits will be
<P>changed, such that they are equal to the permissions specified for the
<P><B>class ACL entry. The IPC other class permission bits will be changed,</B>
<P>such that they are equal to the permissions specified for the <B>other</B>
<P>ACL entry.
<P>
<P>A design may constrain the maximum number of ACL entries that are
<P>written, with a system-wide tunable parameter, <B>aclmax. If the number 
of</B>
<P>ACL entries exceeds the value of <B>aclmax the function will fail (see</B>
<P><B>ERRORS AND RETURNS).</B>
<P>ERRORS AND RETURNS: If the aclipc call is unsuccessful, a value of <B>-l will 
be</B>
<P>returned and errno will be set to indicate the error. Only
<P>implementation-independent errnos are presented.
<P>Under the following conditions, the function aclipc will fail and will
<P>set errno to the specified value (note: if cmd is unspecified, the errno
<P>applies to ACL_CNT, ACL_GET, and ACL_SET):
<P>EINVAL if type is not IPC_SHM, IPC_SEM, or IPC_MSG
<P>EINVAL if the value of id is (1) not a valid message_queue_identifier
<P>and the type was IPC_MSG, (2) not a valid semaphore_identifier
<P>and the type was IPC_SEM, or (3) not a valid shared memory,
<P>identifier and the type was IPC_SHM
<P>EINVAL if cmd is not ACL_CNT, ACL_GET, or ACL_SET
<P>EINVAL if cmd is ACL_SET and the ACL entries do not pass
<P>the validation check
<P>EACCES if the DAC and/or MAC check fails
<P>ENOSPC if cmd is ACL_GET and the space required for the
<P>IPC's object ACL entries exceeds nentries
<P>ENOMEM if cmd is ACL_SET and there is insufficient
<P>space to store the ACL
<P>EINVAL if the number of acl entries exceeds the value of <B>aclmax</B>
<P>
<UL>
  <H2>2.8 shmctl, semctl, &amp; msgctl Functions</H2></UL>DESCRIPTION: The shmctl. 
semctl, and msgctl functions support the following
<P>functionality:
<P>1. they allow a subject to change the user ID. group ID, and
<P>permissions on IPC objects.
<P>SYNOPSIS: No change.
<P>PROCESSING: No change.
<P>ERRORS AND RETURNS: No change.
<P>
<H1><A name="HDR 2 102">REFERENCES</A></H1>[1] Department of Defense Trusted 
Computer Systems Evaluation Criteria. DoD
<P>5200.28-STD, December 1985.
<P>[2] National Computer Security Center, A Guide to Understanding Discretionary 
Access Control in Trusted Systems, NCSC-TG-003 Version-I, September 1987.
<P>[3] UNIX System Access Control List Proposal, C. Rubin, AT&amp;T. May 15. 
1988.
<P>[4] Adding Access Control Lists To UNIX, A. Silverstein, B. McMahon. G. Nuss,
<P>Hewlett-Packard Co.. March 12. 1988.
<P>[5] Discretionary Access Control System Functions, D. H. Steves, IBM, March 
14, 1988.
<P>[6] P1003 .6 Security Extension Proposal: Discretionary Access Control 
Semantics, W. Olin Sibert. Oxford Systems Inc., May 18. 1988.
<P>[7] PlOO3.6 Supplementary Document: Discretionary Access Control. Problems in 
P1003.1 Draft 12 , W. Olin Sibert, Oxford Systems Inc.. May 18, 1988.
<P>[8] P1003.6 Supplementary Document: Comments on Hewlett-Packard ACL Proposal, 
W. Olin Sibert. Oxford Systems Inc., May 18,1988.
<P>[9] Extending The UNIX Protection Model with Access Control Lists, G. 
Fernandez, L. Allen, Apollo Computer Inc., June 1988.
<P>[10] On Incorporating Access Control Lists into the UNIX Operating System S. 
M. Kramer, SecureWare Inc., June 1988.
<P>[11] Trusted UNIX Discretionary Access and Privilege Control Mechanisms, B.D.
<P>Wilner, Infosystems Technology Inc.. June 2,1988.
<P>(12] Access Control List Design, Hewlett Packard, October 21, 1988.
<P>[13] Proposal for Adding Access Control Lists to POSIX, P. B. Flinn, 
SecureWare Inc., July 25, 1988.
<P>[14] Discretionary Access Control Proposal, H. L. Hall, Digital Equipment 
Corporation, Oct. 1988.
<P>[15] Portable Operating System Interface for Computer Environments IEEE Std. 
1003.1-1988
<P></P></BODY></HTML>
